<<<
Attribute enabled software development: illustrated with mobile software applications
>>>
<<<
D:/attr/cepaAESD;
>>>
<<<
kniha
>>>
<<<
CepaAESD
>>>
<<<
Cepa, V. (2007), 'Attribute enabled software development: illustrated with mobile software applications', VDM Verlag, Saarbr\"{u}cken, Germany, (2007)
>>>
<<<
MDD;domain specific abstractions;DSL;@OP;UML;attribute-oriented programming;annotations application;generative programming;MobCon;
>>>

<<<
Language Support for Model-Driven Software Development
>>>
<<<
D:/attr/lang;
>>>
<<<
anotacie + gaast + reflexia (codedom)
>>>
<<<
langSupport
>>>
<<<
Cepa, V. \& Mezini, M. (2004), 'Language Support for Model-Driven Software Development', in Special Issue Science of Computer Programming (Elsevier) on MDA: Foundations and Applications Model Driven Architecture, 2004
>>>
<<<
new;domain abstractions;language extension;DSL;
>>>

<<<
Adding Genericity to a Plug-in Framework
>>>
<<<
D:/attr/markus;
>>>
<<<
markus
>>>
<<<
genericityPlugin
>>>
<<<
@article{genericityPlugin,
 author = {Wolfinger, Reinhard and L\"{o}berbauer, Markus and Jahn, Markus and M\"{o}ssenb\"{o}ck, Hanspeter},
 title = {Adding genericity to a plug-in framework},
 journal = {SIGPLAN Not.},
 issue_date = {Febuary 2011},
 volume = {46},
 number = {2},
 month = oct,
 year = {2010},
 issn = {0362-1340},
 pages = {93--102},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1942788.1868308},
 doi = {10.1145/1942788.1868308},
 acmid = {1868308},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {component templates, composition, generic plug-ins, generic programming, plug-and-play composition, plug-in architectures, run-time adaptation},
}
>>>
<<<
new;plugin;annotations;.net attributes;interface definition;annotations application;
>>>

<<<
other citations
>>>
<<<
D:/attr/other citations;
>>>
<<<
\cite{audioVisualMeta}

\bibitem{audioVisualMeta} Federal Agencies Audio-Visual Working Group (2009), 'Embedding Metadata in Digital Audio Files', available on \url{http://www.digitizationguidelines.gov/audio-visual/documents/Embed_Intro_090915.pdf} (07/11/2012)

\cite{jpegMeta}

\bibitem{jpegMeta} Gecko\&Fly (2012), 'Remove and Insert Metadata Keywords into Jpeg Images for Search Engine', available on \url{http://www.geckoandfly.com/3172/remove-and-insert-metadata-keywords-into-jpeg-images-for-search-engine/} (07/11/2012)

\cite{pdfMeta}

\bibitem{pdfMeta} Weisinger, D. (2006), 'Embedded Document MetaData', in Formtek Blog, available on \url{http://www.formtek.com/blog/?p=46} (07/11/2012)
>>>
<<<
othercitations
>>>
<<<
other citations
>>>
<<<
new;citations;
>>>

<<<
.NET Framework - A solution for the next generation tools for system-level modeling and simulation
>>>
<<<
D:/attr/application/.NET Framework - A solution for the next generation tools for system-level modeling and simulation;
>>>
<<<
Framework pre simulaciu obvodov ak som spravne pochopil, ktory na modelovanie pouziva jazyk C# s jeho atributmi.
>>>
<<<
esys.net
>>>
<<<
Lapalme, J.; Aboulhamid, E. M.; Nicolescu, G.; Charest, L.; Boyer, F. R.; David, J. P. \& Bois, G. (2004), '.NET Framework -- A Solution for the Next Generation Tools for System-Level Modeling and Simulation', in DATE, IEEE Computer Society, pp. 732--733
>>>
<<<
ESys.NET;.NET attributes;annotations application;
>>>

<<<
Alias Annotations for Program Understanding
>>>
<<<
D:/attr/application/Alias Annotations for Program Understanding;
>>>
<<<
POuzivaju special anotacie (skor by som povedal ze vkladaju nove keywords) na definovanie pristupu k alias objektom.
Kvoli zjednoduseniu prace navrhuju aj jednoduche algoritmy na automaticke anotovanie programu.

This paper described AliasJava, an annotation system for Java that places structural and temporal  bounds on aliases, enabling developers to reason more directly about aliasing in object-oriented systems.
>>>
<<<
aliasAnnotations
>>>
<<<
Aldrich, J.; Kostadinov, V. \& Chambers, C. (2002), 'Alias annotations for program understanding', in Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications, OOPSLA '02, ACM, pp. 311--330
>>>
<<<
@OP;special annotations;annotations application;superimposition of annotations;annotations vs keywords;locality;dumb;
>>>

<<<
An extensible framework for middleware design based on concurrent event-based AOP
>>>
<<<
D:/attr/application/An extensible framework for middleware design based on concurrent event-based AOP;
>>>
<<<
Navrhuju nejaky AOP framework pre middleware, ktory pouziva anotacie na POJO na definiciu aspektov. Rozdeluju programatorov na dve roly - aspektovy programator, ktory tvori aspekty, a clientsky (aplikacny) programator, ktory vytvara pointcuts a teda tvori aplikaciu. chcu totiz aplikovat skompilovane aspekty na kod (kniznice aspektove). Ich aspekty maju byt loosely-coupled.

Mozno by stalo za to spravit taky vseobecny framework.
>>>
<<<
aopFramework
>>>
<<<
Marques, E.; Veiga, L. \& Ferreira, P. (2010), 'An extensible framework for middleware design based on concurrent event-based AOP', in Proceedings of the 9th International Workshop on Adaptive and Reflective Middleware, ARM '10, ACM, pp. 26--31
>>>
<<<
@OP;dynamic AOP;Java annotations;annotations application;navigation;separated aspects;
>>>

<<<
Applying Code Generation Techniques to the J2EE Development
>>>
<<<
D:/attr/application/Applying Code Generation Techniques to the J2EE Development;
>>>
<<<
Definuje anotacie na strane 7 ako @OP languages enable special declarative tags, or attributes, to be embedded within the body of the code.
Porovnava s C++ makrami.
naznacuje ze oproti makram sa z anotacii generuje kod do druhych suborov a nie priamo do tela co povazuje za vyhodu, lebo sa tym neznecistuje kod (oproti makru pre reverse engineering).
Priklad pouzitia a vyhod pouzitia XDocletu pre ejb.
Active a passive code generators.
>>>
<<<
applyingCodeGeneration
>>>
<<<
Monnox, A. (2005), 'Applying Code Generation Techniques to the J2EE Development', in Pearson informIT, June 10, 2005, available on \url{http://www.informit.com/articles/article.aspx?p=389718} (31/10/2012)
>>>
<<<
@OP;generative programming;templates;Velocity;alternatives;competition;XDoclet;EJB;annotations definition;
>>>

<<<
Aspect-Oriented Programming with C# and .NET
>>>
<<<
D:/attr/application/Aspect-Oriented Programming with C# and .NET;
>>>
<<<
Pekne rozobratie reflexie v .NET. O metadatach tu hovori nie len ako o @OP ale vlastne o lubobolnych datach o strukturach - teda celkovo o reflexii.
Preskumat implementaciu .NET atributov (najm? moznosti pridavania funkcionality do atributu).
>>>
<<<
aopdotnet
>>>
<<<
Schult, W. \& Polze, A. (2002), 'Aspect-Oriented Programming with C\# and .NET', in Symposium on Object-Oriented Real-Time Distributed Computing, pp. 241--248
>>>
<<<
AOP;@OP;.NET attributes;attribute-oriented programming;metadata theory;annotations application;
>>>

<<<
Attribute-Oriented Programming with Java 1.5
>>>
<<<
D:/attr/application/Attribute-Oriented Programming with Java 1.5, Part 1;
>>>
<<<
Implementacia v podstate AOP pomocou anotacii. Ukazka pouzitia anotacii v JAve.

However, with the inclusion of JSR-175, Java 1.5 has provided a more structured format for including these attributes inside of real code. The attributes are called "annotations" and they can be used to provide metadata for class, method, field, or variable definitions. They must be declared explicitly, and provide a sequence of name-value pairs that can contain any constant value (including primitives, strings, enumerations, and classes).
>>>
<<<
aopJava15
>>>
<<<
Schwarz, D. (2004), 'Attribute-Oriented Programming with Java 1.5', available on \url{http://onjava.com/pub/a/onjava/2004/06/30/insidebox1.html}, (22/10/2012)
>>>
<<<
annotations application;AOP;annotations definition;structured annotations;
>>>

<<<
Design by Contract with JML
>>>
<<<
D:/attr/application/Design by Contract with JML;
>>>
<<<
Pouzivaju specialne anotacne komentare na definovanie kontraktu. Kontrkakt ako pre a post podmienka. A vela o tom.
>>>
<<<
designContractJML
>>>
<<<
@article{designContractJML,
 author = {Flanagan, Cormac and Leino, K. Rustan M. and Lillibridge, Mark and Nelson, Greg and Saxe, James B. and Stata, Raymie},
 title = {{Extended Static Checking for Java}},
 journal = {SIGPLAN Not.},
 issue_date = {May 2002},
 volume = {37},
 number = {5},
 month = may,
 year = {2002},
 issn = {0362-1340},
 pages = {234--245},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/543552.512558},
 doi = {10.1145/543552.512558},
 acmid = {512558},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compile-time program checking},
}
>>>
<<<
special annotations;annotations application;@OP;documenting annotations;JML;code checking;
>>>

<<<
Generative design patterns
>>>
<<<
D:/attr/application/Generative Design Patterns;
>>>
<<<
.. due to the fact that design patterns are written documents that are subject to human interpretation. This makes them vulnerable to the ambiguities in natural language. An incorrect interpretation of a pattern can lead to an incorrect implementation. It would be beneficial to use generative design patterns that generate code. They reduce implementation time, are less prone to programmer error, promote rapid prototyping and code reuse, support performance tuning, and provide better overall software engineering benefits.
pokus o generovanie struktur pre aplikaciu navrhovych vzorov
vseobecny NV je cez variabilne parametre adaptovany na konkretnu situaciu a z toho je vygenerovany kod
generovanie je pomocou javadoc-u - doclet a anotacie
NV su definovane pomocou tychto var parametrov, ich navrh pomocou ich toolu COPS a MetaCOPS
>>>
<<<
generativeDesignPatterns
>>>
<<<
MacDonald, S.; Szafron, D.; Schaeffer, J.; Anvik, J.; Bromling, S. \& Tan, K. (2002), 'Generative design patterns', in Proceedings of the 17th IEEE international conference on Automated software engineering, ASE '02, IEEE Computer Society, Washington, DC, USA
>>>
<<<
design pattern;generative programming;annotations application;XDoclet;special annotations;
>>>

<<<
Implementing Automatic Error Recovery Support for Rich Web Clients
>>>
<<<
D:/attr/application/Implementing Automatic Error Recovery Support for Rich Web Clients;
>>>
<<<
In [9] a new semantic construction called  Reconstructor  is proposed and integrated with OO languages using attribute oriented programming in Java.
Reconstructor ako objekt ktory vracia objekt do konzistentneho stavu, pre kazdu metodu, ktoru je mozno zakazat sa pri jej volani vytvori reconstructor ktory sa dava do stacku. Takto tvoria kontext, s kazdou rekonstruovatelnou operaciu sa vytvara novy kontext.
Programator moze oznacit rekonstruovatelne atributy, metody, a kontexty prave pomocou anotacii (ale to v Jave, a toto je pre RIA a JavaScript, takze predpokladam ze [9]). Vyuzivaju AOP ako take.
>>>
<<<
automaticErrorRecovery
>>>
<<<
Quintela-Pumares, M.; Fernández-Lanvin, D.; Izquierdo, R. \& Fernández-Álvarez, A. M. (2010), 'Implementing Automatic Error Recovery Support for Rich Web Clients', in Proceedings of the 11th international conference on Web information systems engineering, WISE'10, Springer, pp. 630--638
>>>
<<<
Java annotations;annotations application;AOP;@OP;
>>>

<<<
Attribute-oriented Programming in Task-driven Case Study Design and Evolution
>>>
<<<
D:/attr/application/poster2012;
>>>
<<<

>>>
<<<
attTDCSposter
>>>
<<<
Nosá¾, M. (2012), 'Attribute-oriented Programming in Task-driven Case Study Design and Evolution', in POSTER 2012: 16th International Student Conferenece on Electrical Engineering: May 17, 2012, Prague, Czech Technical University in Prague, pp. 1--5.
>>>
<<<
new;annotations application;
>>>

<<<
Preserving the Separation of Concerns While Composing Aspects on Shared Joinpoints
>>>
<<<
D:/attr/application/Preserving the Separation of Concerns While Composing Aspects on Shared Joinpoints;
>>>
<<<
V skratke chce pouzivat semanticke anotacie na to aby dokazal riesit interferenciu viacerych aspektov.
>>>
<<<
preservingSoCsharedJP
>>>
<<<
Marot, A. (2009), 'Preserving the Separation of Concerns While Composing Aspects on Shared Joinpoints', in Proceedings of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications, OOPSLA '09, ACM, pp. 837--838
>>>
<<<
@OP;AOP;annotations application;semantic annotations;SoC;
>>>

<<<
Role-Based Access Control (RBAC) in Java via Proxy Objects using Annotations
>>>
<<<
D:/attr/application/Role-Based Access Control (RBAC) in Java via Proxy Objects using Annotations;
>>>
<<<
Annotations enable developers to associate arbitrary metadata- in our case, access control metadata - with code.

Ak som to spravne pochopil, snazia sa robit RBAC pomocou anotacii, ale tak ze bojuju voci RMI - vytvoria proxy pre kazdu rolu, tzn. ze nejaka rola ani nebude vediet ze niektore metody resp. rozhrania existuju - nie len ze jej bude zakazany pristup!
Pekny system anotacii, aby vyjadrili ze jedna rola je podrolou druhej tak metanatuju sa navzjaom..
>>>
<<<
RBACJavaAnn
>>>
<<<
Zarnett, J.; Tripunitara, M. V. \& Lam, P. (2010), 'Role-based access control (RBAC) in Java via proxy objects using annotations', in Proceedings of the 15th ACM symposium on Access control models and technologies, SACMAT '10, ACM, pp. 79--88
>>>
<<<
RBAC;@OP;annotations application;annotations definition;
>>>

<<<
Smart Composition of Game Objects Using Dependency Injection
>>>
<<<
D:/attr/application/Smart Composition of Game Objects Using Dependency Injection;
>>>
<<<
Principialne predstavuju nejaky framework na tvorbu hier, pricom na kompoziciu vyuzivaju dependency injection. Na DI pouzivaju XML aj anotacie. Anotacia Inject na injekciu, xml na tvorbu sveta.
>>>
<<<
dependencyInjection
>>>
<<<
Passos, E. B.; Sousa, J. W. S.; Clua, E. W. G.; Montenegro, A. A. \& Murta, L. G. P. (2009), 'Smart composition of game objects using dependency injection', in Computers in Entertainment, vol. 7, no. 4, pp. 1--15
>>>
<<<
Java annotations;XML;dependency injection;annotations application;DIP;IoC;
>>>

<<<
Spoon Compile-time Annotation Processing for Middleware
>>>
<<<
D:/attr/application/Spoon Compile-time Annotation Processing for Middleware;
>>>
<<<
Pouziva anotacie v nejakom template jazyku, argumentuje ze anotacie su lepsie nez XML a ze je nimi mozne zdvihnut level abstrakcie (tak ako aj XMLkom).  Argumentuje ze template based metaprogramming je lepsia alternativa nez AOP. Spoon je vlastne nastroj na implementaciu pozadia vykon?vania z anotacii. Fine-grained modification of programs. Vyzera to ako anotacny procesor, ale s v?csou invazivnou silou + pomaha si so sablonami v nativnej Java a s anotaciami.

Annotations are an interesting alternative to deployment descriptors because they?re natively supported in a typed and integrated way, making configuration more straightforward by limiting structural information redundancy. Annotations and metadata in general have proven to be extremely useful for ensuring better separation of concerns and for optimization. By defining the right annotations, you can raise the program?s abstraction level and talk about intentions rather than having to use complex middleware-level APIs, making the program less coupled to a particular technology. However, you must process the annotations to modify the program?s semantics and tune them with regard to a given execution context.
>>>
<<<
spoonPawlak
>>>
<<<
Pawlak, R. (2006), 'Spoon: Compile-time Annotation Processing for Middleware', in IEEE Distributed Systems Online, vol. 7, no. 11
>>>
<<<
annotations vs XML;annotations theory;templates;MDD;service component architecture;@OP vs XML;Java annotations;structured annotations;SoC;domain abstraction;spoon;
>>>

<<<
Tool Support for Continuous Maintenance of State Machine Models in Program Code
>>>
<<<
D:/attr/application/Tool Support for Continuous Maintenance of State Machine Models in Program Code;
>>>
<<<
Zda sa ze pouzivaju anotacie pri modelovani state machines v kode, trieda je stav, metoda je transition a anotacie nad metodou definuju cielovy stav. Podstatou je asi to, ze model mapuju do kodu.
>>>
<<<
stateMachine
>>>
<<<
Balz, M.; Striewe, M. \& Goedicke, M. (2010), 'Tool support for continuous maintenance of state machine models in program code', in Proceedings of the IEEE/ACM international conference on Automated software engineering, ASE '10, ACM, pp. 175--176
>>>
<<<
annotations application;
>>>

<<<
Addressing Ubiquitous Software Complexity with Mobile Containers
>>>
<<<
D:/attr/application/configuration/Addressing Ubiquitous Software Complexity with Mobile Containers;
>>>
<<<
Predstavuje MobCon, ten svoj conatinerovy generovany framework ci ako to nazvat, ak som to spravne pochopil tak nevytvara staly framework, ale namiesto toho pouziva MDD (generativne programovanie) na generovanie sluzieb ktore by inak poskytoval container.
>>>
<<<
mobconOverview
>>>
<<<
Cepa, V. (2004), 'Addressing Ubiquitous Software Complexity with Mobile Containers', in Proceedings of the Third AOSD Workshop on Aspects, Components, and Patterns for Infrastructure Software, Lancaster, UK, 22. March 2004, pp. 72--74
>>>
<<<
@OP;GAAST;semantic annotations;annotation application;MobCon;generative programming;special annotations;configuration;
>>>

<<<
Supporting Multiple Configuration Sources Using Abstraction
>>>
<<<
D:/attr/application/configuration/Supporting Multiple Configuration Sources Using Abstraction;
>>>
<<<
moj clanok o BTE
>>>
<<<
cejcsBTE
>>>
<<<
Nosá¾, M. \& Porubän, J. (2012), 'Supporting multiple configuration sources using abstraction', in Central European Journal of Computer Science, vol. 2, no. 3, 2012, pp. 283--299, DOI: 10.2478/s13537-012-0015-7
>>>
<<<
annotations application;@OP vs XML;Java annotations;annotations position;locality;internal vs external;configuration;BTE;
>>>

<<<
Type Checking Annotation-Based Product Lines
>>>
<<<
D:/attr/application/configuration/Type Checking Annotation-Based Product Lines;
>>>
<<<
Velmi pekny popis toho co je software product line, ako sa to implementuje pomocou "anotacii" (co su vlastne len direktivy preprocesora - je otazka ci su anotaciami leo ich mozes napisat kdekolvek, nie len nad jazykovy element (pomenovany)). Ake chyby mozu nastat, ake su alternativy k tomuto pristupu, co je to feature model, domain engineering.
Riesia ako typovo chranit generovany kod pri tomto anotacnom pristupe - aby sa nestalo ze sa vyberie jedna feature (read only database - teda bez set na dbs) ale niekde sa vola set, ktory existovat nebude. Potom je tam mnoho mnoho matematiky..
>>>
<<<
typeCheckingAnnBasPL
>>>
<<<
Kästner, C.; Apel, S.; Th\"{u}m, T. \& Saake, G. (2012), 'Type checking annotation-based product lines', in ACM Trans. Softw. Eng. Methodol., vol. 21, no. 3, art. 14, pp. 1--39
>>>
<<<
DSL;MDD;software product line;special annotations;annotations application;dependency;configuration;
>>>

<<<
Using Metadata in Aspect-Oriented Frameworks
>>>
<<<
D:/attr/application/configuration/Using Metadata in Aspect-Oriented Frameworks;
>>>
<<<
The  framework  aspects  need  to  include  logging  refer-ences  inside  advice.  This  entails  a  high  syntactic  coupling relationship  [14]  among  advice  and  the  framework  classes that implement the logging. 
Neto  et  al  [14] present a definition for  syntactic and se-mantic  coupling.  Moreover,  Yang  and  Tempero  [15]  have shown criteria for dealing with indirect coupling.
Vyzera to tak ze pouzivaju metadata (XML/@OP) na to aby definovali nejake body variability pre advices v AOP. Teda nie je to o tom ako pouzit anotacie na to aby sme vedeli kam mapovat advices, ale aby sme vedeli nakonfigurovat advice pre nejaky konkretny joinpoit. Potencialne nejake dobre linky.

Attribute-oriented  programming  is  a program-level  marking  technique  that  allows  the  program-mers  to  mark  program  elements  (e.g.  classes  and  methods) to  indicate  that  they  maintain  application-specific  or  do-main-specific semantics.
>>>
<<<
metadataAOPGuerra
>>>
<<<
Guerra, E. M.; Silva, J.; Silveira, F. \& Fernandes, C. T. (2008), 'Using Metadata in Aspect-Oriented Frameworks', in Proceedings of 2nd Workshop on Assessment of Contemporary Modularization Techniques (ACoM.08) at OOPSLA 2008 -- ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (Nashville, EUA, October 19. -- 23., 2008)
>>>
<<<
AOP;@OP;Java annotations;metadata;XML;annotations application;configuration;annotations definition;
>>>

<<<
A Prolog-oriented extension of Java programming based on generics and annotations
>>>
<<<
D:/attr/application/definicia rozhrani/A Prolog-oriented extension of Java programming based on generics and annotations;
>>>
<<<
Pouziva anotacie na premostenie nejakeho enginu na prolog do javy, anotovanim sa vytvara stub (proxy) ktore bude pre pristup do enginu - jednoduchsie spustanie prologu.
idea -- nie je to trosku prehnane pisanie?
>>>
<<<
prologGenAnn
>>>
<<<
Cimadamore, M. \& Viroli, M. (2007), 'A Prolog-oriented extension of Java programming based on generics and annotations', in Proceedings of the 5th international symposium on Principles and practice of programming in Java, PPPJ '07, ACM, pp. 197--202
>>>
<<<
prolog;annotations application;Java annotations;@OP;annotations usage;idea;
>>>

<<<
GUI GENERATION BASED ON LANGUAGE EXTENSIONS
>>>
<<<
D:/attr/application/definicia rozhrani/GUI GENERATION BASED ON LANGUAGE EXTENSIONS;
>>>
<<<
Attribute oriented programming is a program-level marking technique.

Pouzivaju anotacie pre generovanie GUI. Pekny clanocek, plus dobre spravena analyza @OP.
>>>
<<<
guiGenerationAnns
>>>
<<<
Monteiro, M.; Oliveira, P. \& Goncalves, R. (2008), 'GUI Generation Based on Language Extensions -- A Model to Generate GUI, based on Source Code with Custom Attributes', in ICEIS (1), pp. 449--452
>>>
<<<
Attribute-Oriented Programming;Source Code Model;GUI Generation;Data-Driven Application;@OP;annotations definition;annotations application;
>>>

<<<
GUI Generation from Annotated Source Code
>>>
<<<
D:/attr/application/definicia rozhrani/GUI Generation from Annotated Source Code;
>>>
<<<
Nazov je dost vystizny, pouzivaju tree rewriting. GUI je generovane task-driven metodou. Ak som to spravne pochopil je tam prechod medzi abstraktnym GUI a potoms a da aplikovat nejaky konkretny
>>>
<<<
guiGenerationJelinek
>>>
<<<
Jelinek, J. \& Slavik, P. (2004), 'GUI generation from annotated source code', in Proceedings of the 3rd annual conference on Task models and diagrams, TAMODIA '04, ACM, pp. 129--136
>>>
<<<
@OP;annotations application;generative programming;
>>>

<<<
Runtime Concepts of Hierarchical Software Components
>>>
<<<
D:/attr/application/definicia rozhrani/Runtime Concepts of Hierarchical Software Components;
>>>
<<<
Autori popisuju svoj komponentovy model - SOFA 2.0, ktory sa snazi poskytovat high-level sluzby ako je kompozicia komponentov (hierarchia), rozne styly komunikacie, softverove konektory, dynamicke architektury atd. komunikacia resp definicia komponentov si nevyzaduje implementaciu nejakych SOFA rozhranie alebo tried, ale pouzitim anotacii - tie su nasledne introspektivou skumane a podla toho sa sprava SOFA prostredie (na Jave je to teraz).  Ak to nedovoluje prostredie (J2ME), chystaju generovat SOFA specific code.
>>>
<<<
sofaAnnotations
>>>
<<<
Bures, T.; Hnetynka, P. \& Plasil, F. (2007), 'Runtime Concepts of Hierarchical Software Components', in International Journal of Computer \& Information Science 8, pp. 454--463
>>>
<<<
annotations application;interface definition;java annotations;@OP;
>>>

<<<
Type Safe Composition in .NET
>>>
<<<
D:/attr/application/definicia rozhrani/Type Safe Composition in.NET;
>>>
<<<
Pouziva attributy v C# na definovanie zavislosti, resp. rozhrani - TYPOV pre potreby dynamickej load-time type controly.
>>>
<<<
compositiondotNET
>>>
<<<
Seco, J. C. (2002), 'Type Safe Composition in .NET', in First Microsoft Research Summer Workshop, Cambridge, UK, 2002
>>>
<<<
annotations application;interface definition;C# attributes;
>>>

<<<
A Model Transformation Framework for Domain Specific Languages
>>>
<<<
D:/attr/application/mapovanie na model/A Model Transformation Framework for Domain Specific Languages;
>>>
<<<
Okrem toho co je uz v praci Leveraging Metamodeling and A...

je asi podstatne rozdelenie anotacii na marker annotations a member annotations.


Stereotypes are specified as meta-classes extending UML?s standard metaclasses, and tagged-values are specified as attributes of the extended metaclasses (i.e. stereotypes). -- v spojeni s Leveraging moze byt uzitocne
A stereotype that does not have tagged-values in DSM is mapped to a marker annotation.
A stereotype that has tagged-values in DSM is mapped to a member annotation.
A tagged-value in DSM is mapped to a member variable of a member annotation in DSC.
pouzivaju na spracovanie UML nejaky EMF, Eclipse-UML2, JDT (Eclipse Java Development Tool), MTF

Attribute oriented programming is a program-level
marking technique,

Attributes sepa-rate application?s core logic from application-specific or do-main-specific semantics (e.g. logging and web service func-tions). By hiding the implementation details of those semantics from program code, attributes increase the level of program-ming abstraction and reduce programming complexity, resulting in simpler and more readable programs. The program elements associated with attributes are transformed to more detailed pro-grams by a supporting tool (e.g. pre-processor).
>>>
<<<
modelTransformationDSL
>>>
<<<
Wada, H.; Suzuki, J.; Takada, S. \& Doi, N. (2005), 'A Model Transformation Framework for Domain Specific Languages: An Approach Using UML and Attribute-Oriented Programming', in Proc. of the 9th World Multi-Conference on Systemics, Cybernetics and Informatics, pp. 1--6
>>>
<<<
MDD;annotations;DSL;UML;annotations theory;annotations classification;annotations in UML;declarative transformation;annotations definition;mTurnpike;domain specific abstractions;abstraction;annotations application;
>>>

<<<
Leveraging Component-Based Software Engineering with Fraclet
>>>
<<<
D:/attr/application/mapovanie na model/Leveraging Component-Based Software Engineering with Fraclet;
>>>
<<<
Attribute-Oriented Programming (@op) is a program-level marking technique.

Annotations separate application?s business logic from middleware-specific or domain-specificconcerns.
By hiding the implementation details of those semantics from program code, annotations increase the level of programming abstraction and reduce programming complexity, resulting in simpler and more readable programs

Fractal component framework .. - najv?csi problem vraj je prelinanie sa technickeho s business codom.. - tight coupling
redundancia v metadatach medzi kodom a ADL - linkovanie z ADL do kodu

Pouzivaju anotacie na premostenie abstraktneho modelu komponentov do programovacieho modelu. - pouzivaju spoon na generovanie

anotacie mozu generovat aj nove artefakty nie len injektovat ako AOP
>>>
<<<
leveragingFraclet
>>>
<<<
Rouvoy, R. \& Merle, P. (2009), 'Leveraging Component-Based Software Engineering with Fraclet', Annales des Telecommunications 64, 1--2, pp. 65--79
>>>
<<<
@OP;annotations definition;annotations application;theory;domain specific abstraction;Fractal;Fraclet;Spoon;competition;@OP vs AOP;domain specific abstractions;
>>>

<<<
Leveraging Component-Oriented Programming with Attribute-Oriented Programming
>>>
<<<
D:/attr/application/mapovanie na model/Leveraging Component-Oriented Programming with Attribute-Oriented Programming;
>>>
<<<
Attribute-Oriented Programming (@OP) is a program-level marking technique. Basically, this approach allows developers
to mark program elements (e.g., classes, methods, and fields) with annotationsto indicate that they maintain application-specific or domain-specific concerns.

Besides, working with only one file per component gives a better overview of the program code to the developer.

Ako v podstate pouzivaju anotacie na premostenie abstraktneho modelu komponentu do kodu, namiesto toho aby sa do neho vpletal technical code. Generativnym programovanim sa o to staraju oni.
>>>
<<<
rouvoyLeveragingCOP@OP
>>>
<<<
Rouvoy, R. \& Merle, P. (2006), 'Leveraging Component-Oriented Programming with Attribute-Oriented Programming', in Proceedings of the 11th International ECOOP Workshop on Component-Oriented Programming, WCOP'06, Technical Report, volume 2006'11. Karlsruhe University, Nantes, France, July 2006
>>>
<<<
@OP;attribute-oriented programming;annotations application;history?;component-oriented programming;annotations definition;internal vs external;generative programming;Spoon;AOP;competition;Fractal;
>>>

<<<
Leveraging Metamodeling and Attribute-Oriented Programmingto Build a Model-driven Framework for Domain Specific Languages
>>>
<<<
D:/attr/application/mapovanie na model/Leveraging Metamodeling and Attribute-Oriented Programmingto Build a Model-driven Framework for Domain Specific Languages;
>>>
<<<
DSC transformer premostuje UML a DSC (domain specific code) s anotaciami. Dynamicky kod je dodavany manualne. A stereotype in DSM is mapped to a marker annotation in DSC. A tagged-value in DSM is mapped to a member annota-tion in DSC. 

marker anno-tations  and member annotations

V skratke, pouzivaju @OP na to, aby spravili prechod v MDD od Abstract Code ku konkretnemu plynulejsie. Reprezentuju domenove abstrakcie v kode pomocou anotacii. Medzi abstrkatnym modelom a abstrkatnym kodom je teda priame mapovanie, priamy kod a priamy model sa generuju z tychto.

Attribute oriented programming is a program-level
marking technique,
>>>
<<<
leveragingMetamodelingTurnPike
>>>
<<<
Wada, H. \& Takada, S. (2005), 'Leveraging Metamodeling and Attribute-Oriented Programming to Build a Model-driven Framework for Domain Specific Languages', in Proc. of the 8th JSSST Conference on Systems Programming and its Applications
>>>
<<<
annotations application;Java annotations;domain-specific abstractions;model mapping;annotations theory;annotations classification;annotations and UML;annotations definition;mTurnpike;
>>>

<<<
Modeling Turnpike: a Model-Driven Framework for  Domain-Specific Software Development
>>>
<<<
D:/attr/application/mapovanie na model/Modeling Turnpike a Model-Driven Framework for  Domain-Specific Software Development;
>>>
<<<
Attribute-oriented programming is a program marking technique [6]. Programmers can mark program elements (e.g. classes and methods) to indicate that they maintain domain-specific semantics.
V podstate je to na udrziavanie konzistencie medzi modelom a kodom, inak to co v ostatnych mTurnpike clankoch ale len so sustredenim na mTurnpike.
Chcu podporovat lubovolny DSL - ale musi byt postaveny ako UML profil.
Namiesto toho aby musel programator pracovat na nizsej forme abtraklcie v generovanom kode, pracuje s tzv. domenovo specifickym kodom (DSC, vs DSM - mdoel), ktory je anotovany a generovanie deploymentu a detailov je odlozene na neskor z anotacii (resp. anotacie sluzia na mapovanie kodu spat na model?).
Pre transformaciu pouziva deklarativne transformacne pravidla pre transformaciu DSM na DSC a holy UML model a tie nasledne spaja do kompilovatelneho kodu.
Oddelenie ale zaroven automaticke prepojenie modelu s kodom.
Rozsirenia: podpora transformacii pre viacero DSL sucasne, odosobnenie sa od UML, podporu transformacie aj tiel metod z DSC
>>>
<<<
mTurnpikeOverview
>>>
<<<
Wada, H. \& Suzuki, J. (2005), 'Modeling Turnpike: A Model-Driven Framework for Domain-Specific Software Development', in MoDELS Satellite Events, Springer, pp. 357--358
>>>
<<<
DSL;UML;@OP;mTurnpike;Java annotations;annotations application;annotations definition;model mapping;
>>>

<<<
Supporting Design Patterns with Annotations
>>>
<<<
D:/attr/application/semanticke obohatenie/Supporting Design Patterns with Annotations;
>>>
<<<
In the latest Java version, Java 5, annotations are, in contrary to this paper, introduced by JSR 175 as valid language constructs living outside comments as first-class statements. Deciding to express annotations as well-defined comments is more than syntactic sugar. Because with comments it is no matter preserving the behaviour of the annotated code, thus keeping it possible using current tools, compilers and interpreters. Besides, JSR 175 annotations don?t work at statement level but only for declarations. It would be a showstopper not allowing to annotate at statement level for the presented approach, because a single statement could potentially carry significant semantics. Moreover, not more than one (atomic) Java 5 annotation can be applied to one declaration.

Vkladame anotacie nesuce intentions do kodu a tool nam pomaha rozoznat ci nejde o nejaky pattern a nasledne ho aplikovat. Podobne je mozne aplikovat automaticky anotacie na nejake existujuce DP.
>>>
<<<
designPatternsMeffert
>>>
<<<
Meffert, K. (2006), 'Supporting Design Patterns with Annotations', in Proceedings of the 13th Annual IEEE International Symposium and Workshop on Engineering of Computer Based Systems, ECBS '06, IEEE Computer Society, pp. 437--445
>>>
<<<
annotating unnamed constructs;documenting annotations;annotations application;design patterns;finding patterns;Java annotations;special annotations;structured annotations;
>>>

<<<
Unit Test Support for Java via Reflection and Annotations
>>>
<<<
D:/attr/application/testing/Unit Test Support for Java via Reflection and Annotations;
>>>
<<<
POuzivaju anotacie na oznacenie testovacich tried a metod.
>>>
<<<
unitTestSupprotRefAnn
>>>
<<<
Proulx, V. K. \& Jossey, W. (2009), 'Unit test support for Java via reflection and annotations', in Proceedings of the 7th International Conference on Principles and Practice of Programming in Java, PPPJ '09, ACM, pp. 49--56
>>>
<<<
annotations application;testing;
>>>

<<<
A Java Code Annotation Approach for Model Checking Software Systems
>>>
<<<
D:/attr/application/type checking/A Java Code Annotation Approach for Model Checking Software Systems;
>>>
<<<
Anotacie pouzivaju na definovanie modelu a aj na definovanie specifikacie a neskor to kontroluju.. aky to ma vyznam ked oboje zapisuju do programu celkom nechapem.
>>>
<<<
javaCodeModelCheck
>>>
<<<
Ferreira, G.; Loureiro, E. \& Oliveira, E. A. S. (2007), 'A Java code annotation approach for model checking software systems', in Proceedings of the 2007 ACM symposium on Applied computing, SAC '07, ACM, pp. 1536--1537
>>>
<<<
@OP;special annotations;java doc;annotations application;model checking;
>>>

<<<
Adapting the Java Modeling Language for Java 5 Annotations
>>>
<<<
D:/attr/application/type checking/Adapting the Java Modeling Language for Java 5 Annotations;
>>>
<<<
JML
>>>
<<<
JMLJ5Ann
>>>
<<<
@techreport{JMLJ5Ann,
 author = {Taylor, Kristina B. and Rieken, Johannes and Leavens, Gary T.},
 title = {Adapting the Java Modeling Language for Java 5 Annotations},
 institution = {Department of Computer Science, Iowa State University},
 year = 2008,
 number = {TR \#08-06}
}
>>>
<<<
new;JML;annotations application;
>>>

<<<
Compile-time Type-checking for Custom Type Qualifiers in Java
>>>
<<<
D:/attr/application/type checking/Compile-time Type-checking for Custom Type Qualifiers in Java;
>>>
<<<
idea: netrewba varovat pouzivatela ak prerkyva premennu ale potom ju nepouziva? Stanov pripad..

            int index = NOT_FOUND;
            if (rank == 0) {
                int index = hash(buffer[i]); // tu je chyba
                printf("Zaciatocny index pre %s je %d. Rozposielam...\n", buffer[i], index);
            }
            MPI_Bcast(&index, 1, MPI_INT, 0, MPI_COMM_WORLD);
            printf("Rank %d prijal zaciatocny index (%d) pre %s.\n", rank, index, buffer[i]);

zaoberaju sa aj javou 7 a novou specifikaciou JSR 308. Type checking s podporou anotacii, anotaciou viem nico povedat..

@NonNull a pod.

precitat spec o jsr 308
>>>
<<<
compileTimeCustumQJ
>>>
<<<
Papi, M. M. \& Ernst, M. D. (2008), 'Compile-time type-checking for custom type qualifiers in Java', in Companion to the 22nd ACM SIGPLAN conference on Object-oriented programming systems and applications companion, OOPSLA '07, ACM, pp. 723--724
>>>
<<<
idea;@OP;Java 7;annotations application;theory;annotations usage;program checking;type checking;unnamed constructs;
>>>

<<<
Propagation of JML non-null annotations in Java programs
>>>
<<<
D:/attr/application/type checking/Propagation of JML non-null annotations in Java programs;
>>>
<<<
Automacitky propaguju JML nonnull anotaciu, tam kde je to odvoditelne.
>>>
<<<
propagationJMLNonNull
>>>
<<<
Cielecki, M.; Fulara, J.; Jakubczyk, K. \& Jancewicz, L. (2006), 'Propagation of JML non-null annotations in Java programs', in Proceedings of the 4th international symposium on Principles and practice of programming in Java, PPPJ '06, ACM, pp. 135--140
>>>
<<<
JML;@OP;annotations;semantic annotations;constraints;annotations application;type checking;program checking;documenting annotations;
>>>

<<<
A Graph Transformation-Based Approach for applying MDA to SOA
>>>
<<<
D:/attr/competition/A Graph Transformation-Based App roach for applying MDA to SOA;
>>>
<<<
Aplikuje nejaky story driven modeling ci co na MDA ktore chcu pouzit na generovanie SOA. Z UML standard profilu (PIM) je nejaky premostovac do SOA profilu (PSM) a pricom povauzju aspekty ako ?profily? v kode. Na naviazanie aspektu pouzivaju anotacie.

Pre-process weaving is in fact a special kind of AOP, known as Attribute Oriented Programming. XDoclet [15] is a famous attribute oriented programming tool. With standardizing annotation in Java 5 most of the time attributes are defined using annotation and we have used the same approach.
>>>
<<<
MDAtoSOA
>>>
<<<
Taghizadeh, F. \& Taghizadeh, S. R. (2009), 'A Graph Transformation-Based Approach for Applying MDA to SOA', in Proceedings of the 2009 Fourth International Conference on Frontier of Computer Science and Technology (FCST '09). IEEE Computer Society, Washington, DC, USA, pp. 446--451
>>>
<<<
AOP;AOSD;annotations application;MDA;SOA;Aspect;competition;
>>>

<<<
Commercialization of AOSD The Road Ahead
>>>
<<<
D:/attr/competition/Commercialization  of  AOSD  The  Road  Ahead;
>>>
<<<
V kratkosti uvadza @OP ako konkurenciu AOP, jemne rozobera.
>>>
<<<
commofAOSD
>>>
<<<
Bodkin, R. (2003), 'Commercialization of AOSD: The Road Ahead', in AOSD Workshop on Commercialization of AOSD Technology, pp. 1--5
>>>
<<<
AOP;competition;annotations in AOP;
>>>

<<<
AnnaBot: A Static Verifier for Java Annotation Usage
>>>
<<<
D:/attr/dependency/AnnaBot A Static Verifier for Java Annotation Usage;
>>>
<<<
Stavia skor na praxi nez na nejakom research, v prvom rade nedefinuje @OP ale skor sa zaobera vyhradne anotaciami v Jave. Uvadza priklad pochybenia v tomto smere (JPA anotacie na fieldoch a getteroch sucasne).
Constrainty sa zapisuju ako Claim-y, bud v Jave priamo alebo ako java-like dsl (declarative) - teda teoreticky by malo byt mozne zapisat lubovolny constraint - ale nemyslimze to je tento pripad. Podla future work mozem povedat ze je to dost slabe.
Spomina Aval ale ako rozidel uvadza ze oni chcu ist cez metaanotacie, cim si vyzaduju aby sa o definiciu podmienok staral poskytovatel API, jemu o to nejde.
>>>
<<<
annaBot
>>>
<<<
Darwin, I. F. (2010), 'AnnaBot: A Static Verifier for Java Annotation Usage', in Proceedings of the 2nd International Workshop on Defects in Large Software Systems, DEFECTS '09, ACM, New York, USA, pp. 1--7
>>>
<<<
@OP;attribute-oriented programming;annotations constraints;annotations dependency;Java annotations;zavislost;
>>>

<<<
Annotation Framework Validation using Domain Models
>>>
<<<
D:/attr/dependency/Annotation Framework Validation using Domain Models;
>>>
<<<
The Java type system for annotations is not expressive enough to assure that the use of annotations is correct.

rozdelenie na code-wise validations; structural validations

AVal robi dve veci: explicitne urcuje zavislosti, a ich definiciu robi lokalnou voci anotaciam na ktore sa vztahuje.
Annotation model ako UML model anotacii a ich vztahov medzi nimi.
Ak to spravne chapem, tak namiesto toho aby tam davali len metaanotacie sa snazia vytvarat akysi metamodel - model anotacii a kodu a ten ma viest validaciu.
Ako dopyty pre kontrolu pouzivaju OCL queries na EMF model, zda sa ze tym chcu dosiahnut univerzalnost, namiesto programovanie len napisem v OCL co chcem zabezpecit a idem.
Velmi dobry related works.
>>>
<<<
avalFramework
>>>
<<<
Noguera, C. \& Duchien, L. (2008), 'Annotation Framework Validation Using Domain Models', in Proceedings of the 4th European conference on Model Driven Architecture: Foundations and Applications, ECMDA-FA '08, Springer, pp. 48--62
>>>
<<<
Java annotations;AVal;annotations constraints;annotations dependency;annotation model;annotations classification;zavislost;
>>>

<<<
AVal: an Extensible Attribute-Oriented Programming Validator for Java
>>>
<<<
D:/attr/dependency/AVal;
>>>
<<<
Attribute-oriented programming (@OP) is a program-level marking technique that al-lows developers to declaratively enhance the programs through the use of metadata. More precisely, developers can mark program elements (e.g., classes, methods, fields) with attributes (annotations) to indicate that they maintain application-specific or domain-specific semantics [23]. In contrast to prevous uses of attributes for program genera-tion or transformation [13, 18], annotations are placed in the program by the program developers, as opposed to specialized tools, which use annotations to pass information from one processing phase to the next.

Annotations are usually represented as types that can contain a number of parameters, or elements, that serve as containers of the enclosed metadata.

Definuju pojem AttDSL ako atributovy DSL.
In JUnit, if the programmer misspells the Test annotation, the Java compiler will flag the error, whereas this is not true for naming conventions.
Dve druhy validacii: code-wise validations - voci kodu; structural validations - navzajom
Inside usage pattern. Requires, prohibits, RefersTo, matches (vyzera ze ide o matchovanie regexpov), Avaltarget (ako target), Type.
Rozsirenie si ziada metaanotaciu a jej implementaciu (validator implementujuci checkovanie danej podmienky).
Umoznuje docasne nahradit implementaciu anotacii ku ktorych zdrojom nemame pristup.
Testuju to na 3 frameworkoch. Vyzera to lahko, mohli by sme len rozisirit AVal o podporu toho co chceme my.

idea: vyuzivat constrainty na derivovanie anotacii -> pomoc pri oprave chyb
>>>
<<<
avalValidator
>>>
<<<
Noguera, C. \& Pawlak, R. (2007), 'AVal: an Extensible Attribute-Oriented Programming Validator for Java: Research Articles', in J. Softw. Maint. Evol., vol. 19, no. 4, July 2007, pp. 253--275
>>>
<<<
annotations definition;Java annotations;annotations dependency;annotations constraints;AttDSL;naming conventions;annotation usage pattern;AVal;annotations theory;history;structured annotations;zavislost;annotations alternatives;theory;optimization;idea;dumb;
>>>

<<<
Co-evolving Annotations and Source Code through Smart Annotations
>>>
<<<
D:/attr/dependency/Co-evolving Annotations and Source Code through Smart Annotations;
>>>
<<<
Annotations are a means to attach additional metadata to the source code of a system. Nowadays, more and more technologies rely on the presence of such annotations in the source code: beyond their use for documentation purposes, annotations impact the behaviour of the system.

Problem evolucie kodu, ktora moze narusit plantost anotacii, oni navrhuju system v ktorom si definujem podmienky ake platia pre anotacie, na tie podmienky vyuzivaju metaanotacie a staticke finalne cleny anotacneho typu.
Pouzivaju SOUL, nejaky prolog-like logicky jazyk na definovanie podmienok.

Sufficient queries allow identifying source code entities that are missing an applicable annotation. - to nase s anotovanym objektom

niekedy je podmienka prilis genericka, vtedy sa daju pozuit anotacie DoesApply (ak sa ma podmienka vztahovat aj na tento element kodu) alebo doesnotapply (ak sa na toto vztahovat nema).

Pouzivaju eclipse plugin.

priklad na riesenie fragile pointcut problemu - napriek tomu ze anotaciami sa zbavime zavislosti na strukture programu (kodu), stale sa moze stat ze zabudneme oanotovat to co ma byt anotovane (co nejako moze zavisiet na kode) - preto dat kontrolu pouzitia anotacii - moja otazka teraz znie: neda sa to spravit priamo napisanim vhodneho pointcutu? mozno bude velmi zlozity, ale aj tak.. teraz hovorim konkretne o ich priklade. lebo tu zavislost pisem aj tak ku kodu a teda tie anotacie su zavilse na strutkture kodu

potom priklad s EJB a jej tromi anotaciami..
>>>
<<<
coevolvingAnn
>>>
<<<
Kellens, A.; Noguera, C.; Schutter, K. D.; Roover, C. D. \& D'Hondt, T. (2010), 'Co-evolving Annotations and Source Code through Smart Annotations', in Proceedings of the 2010 14th European Conference on Software Maintenance and Reengineering, CSMR '10, IEEE, pp. 117--126
>>>
<<<
@OP;attribute-oriented programming;annotation fragility;annotations constraints;annotations dependency;AOP;pointcut fragility;annotations definition;documenting annotations;zavislost;
>>>

<<<
Declaring and Enforcing Dependencies Between .NET Custom Attributes
>>>
<<<
D:/attr/dependency/Declaring and enforcing dependencies between .NET custom attributes;
>>>
<<<
Pekne spisane, ukazuje ako atributy mozu byt pouzite na tvorbu DSL. Ako motivaciu ku kontrole zavislosti uvadzaju to, ze si vsimli, ze je to cast kodu, ktora sa stale opakuje.
Rozlisuje dva typy zavislosti - required a disallowed.
Nedovoluje klast dependencies medzi susedne atributy, tj atribut na fielde nemoze klast zavislost na atribute na metode.
Rozsiritelny ale zavisly na strukture ADC.
>>>
<<<
declDependencies.net
>>>
<<<
Cepa, V. \& Mezini, M. (2004), 'Declaring and Enforcing Dependencies Between .NET Custom Attributes', in GPCE, Lecture Notes in Computer Science, Springer, pp. 283--297
>>>
<<<
DSL;.NET attributes;annotations dependency;metaannotations;annotations constraints;zavislost;
>>>

<<<
DEFINING ANNOTATION CONSTRAINTS IN ATTRIBUTE ORIENTED
>>>
<<<
D:/attr/dependency/DEFINING ANNOTATION CONSTRAINTS IN ATTRIBUTE ORIENTED;
>>>
<<<
Porubanov clanok. Zaujimave su idei vzorov pouzitia anotacii. Trebalo by vyskusat, ci je mozne naozaj lubovolne obmedzenie pouzitia.

Parent-child relation
Mutual exclusivity
Unique annotation occurrence (@Id)
Occurrence of multiple annotations
Annotation values referencing other elements

idea -- vzory poriadne
>>>
<<<
annotationsConstraints
>>>
<<<
Ruska, Š. \& Porubän, J. (2010), 'Defining Annotation Constraints in Attribute Oriented Programming', in Acta Electrotechnica et Informatica, no.4, vol.10, pp. 89--93
>>>
<<<
Java annotations;annotations constraints;annotations dependency;documenting annotations;annotation usage pattern;idea;zavislost;
>>>

<<<
Design Pattern Support Based on the Source Code Annotations and Feature Models
>>>
<<<
D:/attr/dependency/Design Pattern Support Based on the Source Code Annotations and Feature Models;
>>>
<<<
Oproti napr Sabovi sa snazia aj o autoamticku aplikaci vzorov + evoluciu, podla typu vzoru aj generuju povinne triedy a podobne. Problem vsak je ze je otazka rozsiritelnosti, ak by sme to spravili tak ako sa mi zda u saba, ze pridanie noveho patternu je len otazka definicie jeho vlastnosti nejakym "claimom", tak mi to pride skvele.
Vyuzivaju Eclipse. A ak som to spravne pochopil, snaizia sa ist z UML do kodu, tj uz v uml developer nanacuje co by sa tam hodilo a oni to dogeneruvaju.
>>>
<<<
designPatternsSupportNavrat
>>>
<<<
Kajsa, P. \& Návrat, P. (2012), 'Design Pattern Support Based on the Source Code Annotations and Feature Models', in Proceedings of the 38th international conference on Current Trends in Theory and Practice of Computer Science, SOFSEM'12, Springer-Verlag, pp. 467--478
>>>
<<<
annotations application;type checking;design patterns;program checking;model mapping;Java;design pattern structure;structural checking;dependency;semantic annotations;documenting annotations;
>>>

<<<
Detecting Metadata Bugs on the Fly
>>>
<<<
D:/attr/dependency/Detecting Metadata Bugs on the Fly;
>>>
<<<
to iste co v Metadata Invarinats: Checking .. ; ale tu predsatvuju tool, ktory to robi, cez nejaky eclipse plugin.
>>>
<<<
detectingMetadataFly
>>>
<<<
Song, M. \& Tilevich, E. (2012), 'Detecting metadata bugs on the fly', in Proceedings of the 2012 International Conference on Software Engineering, ICSE 2012, IEEE, pp. 1455--1456
>>>
<<<
@OP;metadata;annotations;attribute-oriented programming;program checking;annotations consistency;annotations dependency;annotations constraints;DSL;zavislost;
>>>

<<<
Enforcing programming conventions by attribute extension in an open compiler
>>>
<<<
D:/attr/dependency/Enforcing programming conventions by attribute extension in an open compiler;
>>>
<<<
Proposuju otvoreny compilator ktory umoznuje pridavat semanticku kontrolu (ale nie napr. rozsirovat gramatiku jazyka).
Umoznuju to rozsirenim jazyka o atributy, aspon tak to znie. Chcu pridavat atributy do AST.
DAG - umoznuju referencie medzi atributmi.
Anotuju program aby vedeli odhlaovat semanticke chyby (tzn. ze zadaju nejaku poziadavku ako atribut - napr. ze metoda je entry - vstup do synchronizovanej sekcie; nasledne sa kontroluje ci sa tato metoda zacina volanim metody implementujucej vstup do chranenej sekcie) pre kniznice.
>>>
<<<
attributeExtensionOpenComp
>>>
<<<
Hedin, G. (1996), 'Enforcing programming conventions by attribute extension in an open compiler', Lund University, Department of Computer Science, 1996
>>>
<<<
Door Attribute grammars;attributes;history;program checking;type checking;special annotations;
>>>

<<<
Extended Static Checking for Java
>>>
<<<
D:/attr/dependency/Extended Static Checking for Java;
>>>
<<<
Nepouzivaju ozajstne anotacie, ale simuluju komentarmi. Pokusaju sa o rozsirene staticku kontrolu na modularnej urovni (po metodach a pod.). Anotacie pouzivaju na definovanie constraintov ohladom kodu. Pouzivaju Theorem proving.
Pri experience tu hovoria o annotation overhead, ked musia anotovat vela.
Vyznam prilkadaju najma v maintenance.
>>>
<<<
staticCheckingJava
>>>
<<<
@article{staticCheckingJava,
 author = {Flanagan, Cormac and Leino, K. Rustan M. and Lillibridge, Mark and Nelson, Greg and Saxe, James B. and Stata, Raymie},
 title = {{Extended Static Checking for Java}},
 journal = {SIGPLAN Not.},
 issue_date = {May 2002},
 volume = {37},
 number = {5},
 month = may,
 year = {2002},
 issn = {0362-1340},
 pages = {234--245},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/543552.512558},
 doi = {10.1145/543552.512558},
 acmid = {512558},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compile-time program checking},
}
>>>
<<<
Java annotations;documenting annotations;type checking;type constraints;dependency;program checking;special annotations;
>>>

<<<
Language Support for Design Patterns using Attribute Extension
>>>
<<<
D:/attr/dependency/Language Support for Design Patterns using Attribute Extension;
>>>
<<<
Podobne ako Sabov clanok o patternoch, povedal by som ze rovnake dokonca, akurat namiesto anotacii pouzivaju attribute extension. Pomocou anotacii v komentaroch vedia definovat roly v DP a kontrolovat ich pouzitie.
>>>
<<<
attExtensionHedin
>>>
<<<
Hedin, G. (1997), 'Language Support for Design Patterns Using Attribute Extension', in Proceedings of the Workshops on Object-Oriented Technology, ECOOP '97, Springer, pp. 137--140
>>>
<<<
@OP;attributed grammar;design pattern;annotations constraints;type checking;program checking;
>>>

<<<
Metadata Invariants: Checking and Inferring Metadata Coding Conventions
>>>
<<<
D:/attr/dependency/Metadata Invariants Checking and Inferring Metadata Coding Conventions;
>>>
<<<
Navrhuju invarianty metadat ktore definuju spravne pouzitie metadat. Ukazuju priklady chyb ktore mozu nastat, a je to napr aj chyba pri refaktorizacii kodu na ktory sa odkazuju metadata z XML. Zapis je v ich DSL.
navrhuju aj nejaky algoritmus na automaticke odvodenie invariantov z kodu.
>>>
<<<
metadataInvariants
>>>
<<<
Song, M. \& Tilevich, E. (2012), 'Metadata invariants: Checking and inferring metadata coding conventions', in Proceedings of the 2012 International Conference on Software Engineering, ICSE 2012, IEEE, pp. 694--704
>>>
<<<
@OP;metadata;annotations;attribute-oriented programming;program checking;annotations consistency;annotations dependency;annotations constraints;DSL;zavislost;internal vs external;
>>>

<<<
Preserving Design Patterns using Source Code Annotations
>>>
<<<
D:/attr/dependency/Preserving Design Patterns using Source Code Annotations;
>>>
<<<
Pouzivat custom anotacie na to aby sme zachytili a udrzali design pattern v kode.
Definicia konkretnej anotacie pre nejaky DP je ale opat pomocou metaanotacii ktore urcuju podmienky za akych nie je design pattern broken. Nedalo by sa to spravit vylucne nejakym nastrojom ako je napr. Aval? !!!!!
Hovoria aj o nejakej aplikacii rozdielov v implementacii DP co moze byt dosiahnute zmenou definicie anotacneho typu pre DP anotaciu - mozno by sa na to dal pouzit daleion.
>>>
<<<
designPatternsSabo
>>>
<<<
Sabo, M. \& Porubän, J. (2009), 'Preserving Design Patterns using Source Code Annotations', in Journal of Computer Science and Control Systems, vol. 2, no. 1, pp. 53--56
>>>
<<<
design patterns;annotations;Java;design pattern structure;structural checking;program checking;annotations application;dependency;semantic annotations;documenting annotations;idea;
>>>

<<<
Reachability Analysis for Annotated Code
>>>
<<<
D:/attr/dependency/Reachability Analysis for Annotated Code;
>>>
<<<
V skratke co som pochopil, kontroluju dosiahnutelny kod v ESC/Java2 (nejaky checker kodu) s JML (anotacny jazyk). Unreacheable moze byt kvoli kode v Jave ale aj kvoli prepodmienkam v JML.
>>>
<<<
reachabilityJanota
>>>
<<<
Janota, M.; Grigore, R. \& Moskal, M. (2007), 'Reachability analysis for annotated code', in Proceedings of the 2007 conference on Specification and verification of component-based systems: 6th Joint Meeting of the European Conference on Software Engineering and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, SAVCBS '07, ACM, pp. 23--30
>>>
<<<
special annotations;@OP;type checking;program checking;JML;
>>>

<<<
Static Checking of Safety Critical Java Annotations
>>>
<<<
D:/attr/dependency/Static Checking of Safety Critical Java Annotations;
>>>
<<<
SCJ - Safety Critical Java - je nejaka specifikacia pre kriticke aplikacie, maju definovane anotacie, ktore oznacuju aku maju mat bezpecnost jednotlive elementy. Oni robia automaticky cehcker tychto pravidiel - ale zrejme je to adhoc kontroler, dalo by sa to zastresit tiez?

idea - Nie len smer od kodu k anotaciam ale aj naopak - nie len ze napr rozhranie caka objekt anotovany niecim, ale ze anotacia caka nieco od tried - ale to tu uz asi bolo.
>>>
<<<
staticCheckSCJAnn
>>>
<<<
Tang, D.; Plsek, A. \& Vitek, J. (2010), 'Static checking of safety critical Java annotations', in Proceedings of the 8th International Workshop on Java Technologies for Real-Time and Embedded Systems, JTRES '10, ACM, pp. 148--154
>>>
<<<
@OP;Java annotations;annotations application;constraints;dependency;type checking;program checking;
>>>

<<<
Using Annotations to Check Structural Properties of Classes
>>>
<<<
D:/attr/dependency/Using annotations to check structural properties of classes;
>>>
<<<
Pouzivaju nejaky pristup, ktory mapuje artifacty softveru na XML, ktory je ulozeny do databazy, a nasledne podmienky vyjadruju ako XQuery dopyty na databazu.
Argumentuju pre reprezentaciu bytecodu namiesto AST, pretoze nemusime mat pristup ku kodu, a zaroven reprezentacie v bytecode je menej variabilna.
Ukazuju priklad mapovania - pomocou BAT2XML a aj priklad dopytov.
restrictions sa vasltne zapisuju ako query dopyty - udavaju nejake priklady z praxe
Najblizsie k nasemu, lebo nekontroluje len pouzitie anotacii, ale aj vlastnosti ktore vyplyvaju z ich pouzitia a da sa pristup pouzit aj na nas problem bez pritomnosit anotacii.
Nesuvisi priamo s JavaML, ale nieco podobne a neviem teraz aky keyword tam dat.
>>>
<<<
annotationsStrucClasses
>>>
<<<
Eichberg, M.; Schäfer, T. \& Mezini, M. (2005), 'Using Annotations to Check Structural Properties of Classes', in Proceedings of the 8th international conference, held as part of the joint European Conference on Theory and Practice of Software conference on Fundamental Approaches to Software Engineering, FASE '05, Springer, pp. 237--252
>>>
<<<
@OP;attribute-oriented programming;structural dependency;annotations dependency;annotations constraints;XML;JavaML;zavislost;
>>>

<<<
The Literate-Programming Paradigm
>>>
<<<
D:/attr/documentation/Cordes-Literate-Programming;
>>>
<<<
strucne a povedal by som aj jasne vysvetlenie paradigmy s jedn. prikladmi, LP ako programovanie s "vynucovanim" komentarov,

LP jazyk definuje strukturu programu podla ktorej sa rozlisuju moduly atd.,
nevyhody:
	1. dok. prog. nezapada do klasickeho soft. vyvojoveho cyklu,
	2. je len pre elitu - vedcov,
	3.vynucovanie dok. nemusi dokumentaciu skvalitnit;

navrhuju rozsirenia:
	1. Viacurovnovy obsah pre lepsie strukturovanie dokumentacnych informacii (bol problem s identifikaciou section headerov, lebo vsetky boli na tej istej urovni),
	2. Graficke rozhranie ako alternativa k dok. program. jazyku, namiesto pisania vo Web sa struktury a vlstnosti vyklikaju nativnejsim sposobom,
	3. Debuggovacie nastroje pomahajuce sledovat strukturu lit. programu, priblizuju dok. programovanie na formu konvencneho a tym umoznuju udrzbu aj neautorovi, zaroven to posuva dok. programovanie aj do dalsej fazy vyvojoveho cyklu,
	4. rozsireny index s cielom umoznit lepsi prehlad v indexoch, v povodnom sa mohlo stat ze bola jedna premenna nazvana rovnako ako ina v inom module a boli tie referencie dokopy, umoznenie manazovania rozdelenia indexov podla typu nazvov a podobne (premenne, autorom generovane polozky);

a obmedzenia:
	1. pretlacit striktne zapuzdrenie modulov, aby funckia, resp. blok nacaty v module sa v nom aj skoncil (lahsie sa orientuje v deklaraciach premennych a scope-och) a poziadavka aby sa vsetky funkcie a procedury dali do separovanych modulov,
	2. redukciu dok. prog. prikazov, oproti viacerym prilazom ktore sa venovali aj stylom vypisu ponechat styl na jazyk pre typesetting
>>>
<<<
litProgrammingParadigm
>>>
<<<
Cordes, D. \& Brown, M. (1991), 'The Literate-Programming Paradigm', IEEE Computer, vol. 24, no. 6, pp. 52--61
>>>
<<<
literate programming;documentation;@OP;
>>>

<<<
Document-Oriented Source Code Transformation using XML
>>>
<<<
D:/attr/documentation/Document-Oriented Source Code Transformation using XML;
>>>
<<<
popisany vyznam refaktorizacie a transformacie kodu v zovotnom cykle softveru - evolucia softveru, dolezitost ponechania vsetkych foriem dokumentacie - anotacie, indentation, comentare.

Pustaju sa do toho cez XML - nejaky srcML.
Tymto su schopni pridat nejake vysoko abstraktne syntatkicke informacie bez zasahu do textoveho/comentoveho kontextu suboru - ponechava programatorovi jeho pohlad + pridavanie casti AST.
Cielom pouzitia srcML je neintruzivna transformacia kodu (src -> srcML -> srcML' -> src').
Stazuju sa na nedostatok podporovanych refaktorizacii.
Predstavene na priklade zameny podmieneneho vetvenia za "strazcu" (guarda).
>>>
<<<
docOrientedsourcecode
>>>
<<<
Collard, M. L. \& Maletic, J. I. (2004), 'Document-Oriented Source Code Transformation using XML', in Proceedings 1st International Workshop on Software Evolution Transformations, SET 2004, Delft, the Netherlands, pp. 11--14
>>>
<<<
XML;transformation;refactoring;
>>>

<<<
Experiments in the Use of XML to Enhance Traceability between Object-Oriented Design Specifications and Source Code
>>>
<<<
D:/attr/documentation/Experiments in the Use of XML to Enhance Traceability between Object-Oriented Design Specifications and Source Code;
>>>
<<<
potreba podpory pohladu na cely system pri vyvoji, nielen orientovanie sa na programaticku uroven (top-down creation).

Cstym problemom softver development procesu je ze generuje mnozstvo roznych dokumentov (requirements specs, design specs, ..), ktore vsak nie su prepojene (traceability) - oni sa snazia podporit proces vytvaranim liniek medzi poziadavkami, dizajnom a kodom (pomocou XML technologii - XLink).
pouzivaju XMI pre reprezetaciu UML, JavaML pre sources.
Ciele su tri:
1. mat viac informacii o kode ako su nejake sof. metriky alebo miera kritickosti,
2. umoznit pohlad z viacerych uhlov pomocou transofmracie formatov,
3. vystopovatelnost medzi dizajnom a kodom;

XLink na link base, ale potom nejako tvoria html zobrazujuce linky
>>>
<<<
experimentsXMLTraceability
>>>
<<<
Alves-Foss, J.; de Leon, D. C. \& Oman, P. W. (2002), 'Experiments in the Use of XML to Enhance Traceability between Object-Oriented Design Specifications and Source Code', in Proceedings of the 35th Annual Hawaii International Conference on System Sciences, HICSS'02, Volume 9, pp. 276--284
>>>
<<<
views;documentation;XML;traceability;program comprehension;
>>>

<<<
Fluid Source Code Views
>>>
<<<
D:/attr/documentation/Fluid Source Code Views;
>>>
<<<
The definition of a complex software system by means of text based source code documents manifests a highly fragmented, heavily linked, hyperlink-able information space. The application of software development paradigms and principles such as abstraction, object orientation, aspect orientation [2] and separation of concerns means that the definition of software may be highly fragmented. The code implementing a program operation of feature can, potentially, be fragmented over dozens of separate source code documents with often implicit and semi-implicit relationships. This phenomenon has also been described loosely as scatter [3] and delocalized plans [4].

fajnyt clanok na pohlady. je to trosku iny pohlad ako sme chceli, ale princip a aj zmysel maju velmi podobny - ukazuje pohlady cez volania metod, pri volani si viem zobrazit aj telo volanej metody -> nie je obmedzenie na hlbku volania..
>>>
<<<
fluidSourceCode
>>>
<<<
Desmond, M.; Storey, M.--A. D. \& Exton, C. (2006), 'Fluid Source Code Views', in Proceedings of the 14th IEEE International Conference on Program Comprehension, ICPC '06, IEEE Computer Society, pp. 260--263
>>>
<<<
documentation;code views;AOP;Eclipse plugin;code comprehension;
>>>

<<<
Elucidative programming in Java
>>>
<<<
D:/attr/documentation/Normark - Elucidative Programming in Java;
>>>
<<<
vyuzit vztah medzi programovymi fragmentami a programovou dokumentaciou (vysvetlivkami).
LitP stavia ich vztah naopak, najprv komentare, vysvetlenia, "knowledge" (toto vlastne tvori program), a programove fragmenty su ich anotacie (v klas. je to naopak, program tvoria programove fragmenty a ich anotaciami su vysvetlivky).
JavaDoc na komentare externych rozhrani, identifikuju dalsie druhy dokumentacie
	- udrzbova (pre udrzbu, pise sa nakoniec ked je projekt vo finalnom stave),
	autorska (proactive mental understanding, pise si ju autor pre lepsiu formulaciu a pre lepsie pochopenie koderov, pise sa pred alebo pocas implementacie),
	procesna (logy a denniky ze co sa robi). Nevyhoda LitP je, ze si ziada, aby program bol pisany formou komentarov a programove fragmenty su iba ako anotacie.

Studenti pri pokusoch sa snazili pisat formou klasickou, a LitP struktura sa dodavala az nakoniec. ElP pouziva dva zakladne entity, programove a dokumentacne, vyzvou je najm? ich prepojenie. dolezity je pojem navigacneho vztahu, spojenie medzi prvkami v dok a prog, pricom v prehliadaci su dva ramce, jeden pre dokumentaciu a druhy pre program, je potrebne zabezpecit ich navigacnu komunikaciu.
Pritom tento navigacny vztah je slabsi nez fyzicky v LitP, ale zasa umoznuje popisat viacero prog. entit v jednej dok. entite(sekcii).
Elucidator: Pozicie a regiony v kode (pre potreby navigacie) su oznacovane source markermi (dat anotaciami - asi nie). Stranka je generovana na dopyt, nie staticke html - vhodne pre kolaborativne programovanie.
>>>
<<<
elucProgJava
>>>
<<<
Normark, K.; Andersen, M. R.; Christensen, C. N.; Kumar, V.; Staun-Pedersen, S. \& Sorensen, K. L. (2000), 'Elucidative Programming in Java', in The Proceedings on the eighteenth annual international conference on Computer documentation, IPCC/SIGDOC '00, pp. 483--495
>>>
<<<
elucidative programming;literate programming;documentation;code comprehension;
>>>

<<<
Elucidative Programming
>>>
<<<
D:/attr/documentation/normark-elucidative programming;
>>>
<<<
zhrnutie, poziadavky na dokumentacne IDE, nav. vs. fyz. vztahy, source markers - oznacenia v kode kde nie su pomenovane abstrakcie, podrobnejsi navrh toolu. elucidator - program abstractor - inkrementalna abstrakcia, ostatne - vid eluc prog in java
>>>
<<<
elucProgrammingNor
>>>
<<<
Normark, K. (2000), 'Elucidative Programming', Nordic Journal of Computing, vol. 7, no. 2, pp. 87--105
>>>
<<<
elucidative programming;literate programming;documentation;
>>>

<<<
Towards Modern Literate Programming
>>>
<<<
D:/attr/documentation/Towards Modern Literate Programming;
>>>
<<<
Maintenance programmers spend approximately half of their time simply trying to understand the function of program code [28]. This factor alone has been estimated as contributing any-where from 30?90% of the cost of software over its entire life cycle [41].
lack of communication of problem understanding - motivacia preco

Let us change our traditional attitude to the construction of programs: instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining tohuman beings what we want a computer to do.

V podstate prehlad literate programmingu, prehlad jazykov a pod (web family).
Obmedzenia.
>>>
<<<
towardsModernLitP
>>>
<<<
Smith, M. (2001), 'Towards Modern Literate Programming', Honours Project Report, 2001
>>>
<<<
literate programming;software comprehension;structured documentation;
>>>

<<<
Aspects of Internal Program Documentation - An Elucidative Perspective
>>>
<<<
D:/attr/documentation/Vestdam - Aspects of internal program documentationan - an elucidative perspective;
>>>
<<<
tri druhy dokumentaciae
	end-user, interface, internal;
dok. analyzy - dok. popisujuca problem,
dok architektury - popisuje navrh, dizajn, architekturu;

evolucia doklumentacie zaostava za evol. softveru - degeneracia dokumentacie.
Dalej vyznam EluP z praxe - skusali to na nejakych "vzorkach".
Aspekty internej dokumentacie:
1. programovae tutorialy, inline eluc kedy elucidator vklada fragmenty kodu priamo do dokumentacie (aby sa pri citani nenarusoval rytmus preklikavanim);
2. frameworks a navrhove vzory,
3. reviews, revies umoznuju nielen zlepsit kvalitu kodu, ale mohli by zlepsit aj kvalitu dokumentacie, elucidative pristup aj k reviews, kde je mozne sledovat hodnotenie a zaroven fragment kodu ktoreho sa to tyka,
4. podpora od IDE pre pisanie internej dokumentacie
>>>
<<<
aspectsOfInternalDoc
>>>
<<<
Vestdam, T. \& Normark, K. (2002), 'Aspects of Internal Program Documentation -- An Elucidative Perspective', in Proceedings of the 10th International Workshop on Program Comprehension, IWPC '02, pp. 43--52
>>>
<<<
elucidative programming;documentation;evolution;
>>>

<<<
Toward Documentation of Program Evolution
>>>
<<<
D:/attr/documentation/Vestdam - Toward documentation of program evolution;
>>>
<<<
dok : program, pri vyvoji jedna k jednej, ak mame initial doc only, tak dokumentacia ostava a evolvuje iba program.

Navrhuju tool, ktory by umoznoval dokumentaciu evolucie namiesto evolucie dokumentacie. version-aware eluc tool, verziovane zdrojaky, ktore su rozne linkovatelne z dokumentacie.
identifikuju evolucne prvky jemnozrnej evolucie ako napr. pridanie novej abstrakcie a, zmazanie abstrakcie, presunutie, update, a pod.. 

pri "m?kkom" linkovani (link na abstrakciu, nie na konkretny subor a miesto) nam premiestnenie medzi subormi "nedoserie" dokumentaciu :).

hrubozrna evolucia - agregacia mnozstva malych evolucii - tvrdia ze sa neda automatizovat. vyhody pouzitia tohto pristupu - zvyraznenie casti dokumentacie, ktora je out-of-date - najm? odstranenie abstrakcii, resp. pridanie novych, identifikacie nezmenenych a teda stabilnych casti programu a reorganizacie.

male updatey vraj mozu byt ignorovane, pricom velke treba sledovat. spomenute theme-based litP - versioned themes?.
>>>
<<<
towardDocEvol
>>>
<<<
Vestdam, T. \& Normark, K. (2005), 'Toward Documentation of Program Evolution', in Proceedings of the 21st IEEE International Conference on Software Maintenance, ICSM '05, IEEE Computer Society, pp. 505--514
>>>
<<<
elucidative programming;documentation evolution;
>>>

<<<
Concrete Syntax for Objects
>>>
<<<
DSL/embedded/Concrete Syntax for Objects.pdf;
>>>
<<<
Tzv. embedded jazyky, umoznuju vytvarat DSL s lubovolnou syntaxou pre kniznice v GPL. Metaborg.
Kombinuju vyhody "string literal" generovania + modelu kodu (AST) v API (oboje v kontexte generovania kodu) -> inak povedane to co by mal robit externy DSL.
Maju tu peknu kapitolku o teorii prekladacov.
dve fazy definicie -- embedding - gramatika pre vlozenie
	-- assimilation -- pravidla pre asimilaciu DSL do host language
>>>
<<<
concreteSyntax
>>>
<<<
Bravenboer, M. \& Visser, E. (2004), 'Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions', in Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications, OOPSLA '04, ACM, pp. 365--383
>>>
<<<
embedded DSL;DSL;
>>>

<<<
When and How to Develop Domain-Specific Languages
>>>
<<<
D:/attr/DSL/DSL-mernik;
>>>
<<<
DSL
>>>
<<<
mernikDSL
>>>
<<<
Mernik, M.; Heering, J. \& Sloane, A. M. (2005), 'When and How to Develop Domain-Specific Languages', in ACM Comput. Surv., vol. 37, no. 4, December 2005, pp. 316--344
>>>
<<<
new;DSL;embedded DSL;
>>>

<<<
Implementing a Domain-Specific Modeling Environment For a Family of Thick-Client GUI Components
>>>
<<<
D:/attr/DSL/Implementing a Domain-Specific Modeling Environment For a Family of Thick-Client GUI Components;
>>>
<<<
Pekne rozobera DSL.
Ich cielom je reference driven Domain specific modeling. Tj referencna implementacia sluzi ako zdroj pre model aj pre generator, ale nie na manualne migrovanie, ale automaticke generovanie - referencna implementacia sa oanotuje a vytvori sa podla nej metamodel jazyka, a aj generator.

Podobne, ale ako keby som takto vytvaral sablony namiesto generatora? nie je to v konecnom dosledku to iste?
>>>
<<<
implementingDSMEnvGUI
>>>
<<<
Muszynski, M. (2005), 'Implementing a Domain-Specific Modeling Environment For a Family of Thick-Client GUI Components', in The 5th OOPSLA Workshop on Domain-Specific Modeling, OOPSLA '05, Computer Science and Information System Reports, Finland 2005, pp. 1--10
>>>
<<<
DSL;MDD;idea;@OP;annotations application;
>>>

<<<
An experiment in generating Java bytecode using rewritable reference attributed grammars
>>>
<<<
D:/attr/history/attrGrammars/application/An experiment in generating Java bytecode using rewritable reference attributed grammars;
>>>
<<<
clanok sa venuje ReRAG - rewritable referenced attributed grammar, pristup s prepisovanim atributovych gramatik.. zaujimava idea, implementuju prekladac pomocou prepisovania AST, pricom atributy im pri tom posluhuju..
>>>
<<<
reragsExper
>>>
<<<
Ive, A.; Hedin, G. \& Ekman, T. (2004), 'An experiment in generating Java bytecode using rewritable reference attributed grammars', in 11th Nordic Workshop on Programming and Software Development Tools and Techniques NWPER'2004, pp. 65--78
>>>
<<<
attributed grammars;history;Java annotations;
>>>

<<<
W/AGE : The Windsor Attribute Grammar Programming Environment
>>>
<<<
D:/attr/history/attrGrammars/application/WAGE  The Windsor Attribute Grammar Programming Environment;
>>>
<<<
Pouzivaju atributove gramatiky na deklarativne definovanie jazykoveho procesora pre prirodzeny jazyk.
>>>
<<<
wageFrost
>>>
<<<
Frost, R. A. (2002), 'W/AGE: The Windsor Attribute Grammar Programming Environment', in Proceedings of the IEEE 2002 Symposia on Human Centric Computing Languages and Environments, HCC, IEEE Computer Society, pp. 96--98
>>>
<<<
attributed grammar;application;speech recognition;
>>>

<<<
Inversion of Control Containers and the Dependency Injection pattern
>>>
<<<
D:/attr/IoC/Inversion of Control Containers and the Dependency Injection pattern.pdf;
>>>
<<<

>>>
<<<
fowlerIoCDIP
>>>
<<<
Fowler, M. (2004), 'Inversion of Control Containers and the Dependency Injection pattern', available on \url{http://martinfowler.com/articles/injection.html} (16/11/2012)
>>>
<<<
new;IoC;DIP;
>>>

<<<
Attribute Grammar Paradigms - A High-Level Methodology in Language Implementation
>>>
<<<
D:/attr/later/PaakkiAttributeGrammars;
>>>
<<<
Attribute Grammar Paradigms - A High-Level Methodology in Language Implementation
precitat este
>>>
<<<
attributeGrammars
>>>
<<<
Paakki, J. (1995), 'Attribute Grammar Paradigms -- A High-Level Methodology in Language Implementation', in ACM Comput. Surv., vol. 27, no. 2, ACM, pp. 196--255
>>>
<<<
new;attribute grammars;
>>>

<<<
A Gentle Introduction to Metadata
>>>
<<<
D:/attr/metadata/A Gentle Introduction to Metadata;
>>>
<<<
Data o datach. Upozornuje aj na to ze mozu byt reprezentovane rozlicne. Metaudaje samotne neposkytuju pristup k samotnym udajom, a preto mozu byt zverejnene, neviem na co to je dobre v nasom kontexte ale ktovie.
>>>
<<<
gentleMetadata
>>>
<<<
Good, Jeff (2002), 'A Gentle Introduction to Metadata', University of California, Berkeley, available on \url{http://www.language--archives.org/documents/gentle--intro.html} (22/10/2012)
>>>
<<<
metadata;metadata format;
>>>

<<<
A Survey of Techniques for Achieving Metadata Interoperability
>>>
<<<
D:/attr/metadata/A Survey of Techniques for Achieving Metadata Interoperability;
>>>
<<<
Metadata are machine processable data that describe resources, digital or non-digital.
Following Gilliand's definition [Gilliland 2005], we conceive metadata as the total sum of what one can say about any information object at any level of aggregation, in a machine understandable representation. An information object is anything that can be addressed and manipulated by a human or a system as a discrete entity.
Based on this observation, we can identify three main metadata building blocks: we denote the set of content values in a metadata description as metadata instance, the element definitions as metadata schema (Konrektna xml schema, konrketny idsl v @OP), and the language for defining metadata schemes as schema definition language (XMLschema, UML, @OP).
Rozdeluju to an 4 informacne vrstvy, fyzicka vrstva, logicka vrstva (logicke usporiadanie 0 a 1), programatorska (ako je naprogramovane spracovanie) a konceptualna - skutocny vyznam v podstate.
Kazda z tychto vrstiev ma spolocne to, ze informacne elementy su implementovane v terminoch udajoveho modelu - data model for metadata - metadata model. Ten reprezentuje ich semantiku formalnym sposobom - ta je definovana ich mapovanim na korespondujuce entity v aplikacnej domene.
The notion of interoperability can further be subdivided: for Baker et al. [2002], achieving interoperability is a problem to be resolved on three main levels: the transport and exchange level (e.g., protocols), the metadata representation level (e.g., syntactic binding, encoding language), and the level of metadata with their attribute space(e.g., schema elements) and value space(e.g., controlled vocabular-ies).
Tolk [2006] proposes an-other view consisting of six levels: no interoperabilityon the lowest level,techni-cal interoperability (communication infrastructure established) on level one, syn-tactic interoperability (common structure to exchange information) on level two,
semantic interoperability (common information model) on level three, pragmatic interoperability (context awareness) on level four, dynamic interoperability(ability to comprehend state changes) on level five, and conceptual interoperability (fully specified, but implementation independent model) on level six.

Toto by sa breutalne hodilo k mojej diplomovke, maju tam rozoberane ako to zjednocovat a co stoji v ceste.
>>>
<<<
surveyMetadata
>>>
<<<
Haslhofer, B. \& Klas, W. (2010), 'A survey of techniques for achieving metadata interoperability', ACM Comput. Surv., vol. 42, no. 2, pp. 1--42
>>>
<<<
metadata;metadata interoperability;mapping;metadata standards;metadata theory;
>>>

<<<
BabuDB Fast and Efficient File System Metadata Storage
>>>
<<<
D:/attr/metadata/BabuDB Fast and Efficient File System Metadata Storage;
>>>
<<<
Nejaky clanok o efektivnejsom ukladani metadat pre distrubuovane filesystemy, namiesto B stromov nejake LMS ci co.
Z hladiska anotacii priamo asi zbytocne.
>>>
<<<
BabuDB
>>>
<<<
Stender, J.; Kolbeck, B.; H\"{o}gqvist, M. \& Hupfeld, F. (2010), 'BabuDB: Fast and Efficient File System Metadata Storage', in Proceedings of the 2010 International Workshop on Storage Network Architecture and Parallel I/Os, SNAPI '10, IEEE Computer Society, Washington, DC, USA, pp. 51--58
>>>
<<<
external metadata;storage;
>>>

<<<
ClassMock: A Testing Tool for Reflective Classes Which Consume Code Annotations
>>>
<<<
D:/attr/metadata/ClassMock A Testing Tool for Reflective Classes Which Consume Code Annotations;
>>>
<<<
Metadata   is   an   overloaded   term   in   computer   science   and   can   be   interpreted differently  according   to   the   context.   In  the   context   of   object-oriented   programming, metadata is information about the program structure itself such as classes, methods and attributes.

The   use   of   code   annotations   is   also   called   attribute-oriented   programing (Schwarz 2004), which  can be defined as a program-level marking technique used to mark program elements, such as classes, methods  and attributes, with annotations to indicate that they maintain application-specific or domain-specific semantics. This technique introduces a declarative approach inside an imperative programming language.

Predstavuju tool ClassMock, ktory generuje mock triedy - triedy ktore predstavuju fake triedy pre testy - mozu sa menit v detailoch ako je napr. pouzitie anotacie and metodou a pod. To robia pouzitim fluent interface. Fajn pri AOP - testy na pointcuty a pod.
This work addressed the automated tests of classes which uses reflection or consume code annotations.
>>>
<<<
classMock
>>>
<<<
Guerra, E.; Silveira, F. \& Fernandes, C. (2010), 'ClassMock: A Testing Tool for Reflective Classes Which Consume Code Annotations', in Workshop Brasileiro de Metodos Ageis, Conferencia Brasileira sobre Metodos Ageis de Desenvolvimento de Software Agile, Brazil 2010, pp. 1--14
>>>
<<<
@OP;metadata;annotations definition;fluent interface;DSL;AOP;
>>>

<<<
Metadata Principles and Practicalities
>>>
<<<
D:/attr/metadata/Metadata Principles and Practicalities;
>>>
<<<
Poskytuje rozdelenie, ale hovori o metadatach vo velmi vseobecnej rovine.
Embedded metadata - priamo
Associated metadata - vo viazanych fileoch
Third-Party metadata - v 3rd party repozitaroch

mandatory vs optional - ma zmysel v niektorych kontextoch (ci uz ako v konfiguracii, ci ako pri denpendency) hovorit o povinnych a nepovinnych?
>>>
<<<
metadataPrincPract
>>>
<<<
Duval, E.; Hodgins, W.; Sutton, S. \& Weibel, S. L. (2002), 'Metadata Principles and Practicalities', in D-Lib Magazine, vol. 8, no. 4, April 2002
>>>
<<<
metadata;internal vs external;idea;
>>>

<<<
QoS-Aware Component Frameworks
>>>
<<<
D:/attr/metadata/QoS-Aware Component Frameworks;
>>>
<<<
Vseobecne je to o vyuziti @OP v oblasti QoS, ale je tam naznacena moznost vyjadrenia atributov prostrednictvm a) XML; b) priamo metadatami (anotaciami); c) a bejakymi konceptualnymi modelmi. Cize je tu naznak toho, ze atributy sa daju povazovat za metadata a ze je azda mozne ich odosobnit od implementacie - ale my sa na to pozrieme prave naopak, pojem atributy budeme nahradzovat internymi metaudaj
>>>
<<<
qosAware
>>>
<<<
de Miguel, M.A.; Ruiz, J.F. \& Garcia, M. (2002), 'QoS--aware component frameworks', in Tenth IEEE International Workshop on Quality of Service 2002, pp. 161--169
>>>
<<<
metadata;abstract layers;annotations position;locality;
>>>

<<<
Reusable Enterprise Metadata with Pattern-Based Structural Expressions
>>>
<<<
D:/attr/metadata/Reusable Enterprise Metadata with Pattern-Based Structural Expressions;
>>>
<<<
Novy format metadat, ktory by mal nahradit Anotacie a XML. Celkom fajn porovnanie tychto dvoch. Stavia najma na tom ze anotacie nie su op?tovne pouzitelne a nevyjadruju strukturalne informacie. Uzitocne aj pri Matovom, robia tam nejaku projekciu ich metadat Eclipse pluginom.
>>>
<<<
reusableEnterprise
>>>
<<<
Tilevich, E. \& Song, M. (2010), 'Reusable enterprise metadata with pattern-based structural expressions', in Proceedings of the 9th International Conference on Aspect-Oriented Software Development, AOSD '10, ACM, pp. 25--36
>>>
<<<
Java annotations;@OP vs XML;metadata;annotations position;locality;internal vs external;
>>>

<<<
The RAND Metadata  Management System  (RMMS)
>>>
<<<
D:/attr/metadata/The RAND Metadata  Management System  (RMMS);
>>>
<<<
Metadata denotes definitional and descriptional information about databases, simulation models, and procedures.
Hovoria o vyzname metadat (z pohladu databaz samozrejme),
>>>
<<<
randMetadata
>>>
<<<
National Defense Research Institute (U. S.); Cammarata, S.; United States Department of Defense Office of the Secretary of Defense; United States Army; United States Air Force \& Arroyo Center (1995), 'The Rand Metadata Management System (Rmms: A Metadata Storage Facility to Support Data Interoperability, Reuse, and Sharing)'
>>>
<<<
metadata;database;
>>>

<<<
AOM Metadata Extension Points
>>>
<<<
D:/attr/metadata/AOM/AOM Metadata Extension Points;
>>>
<<<
Z toho co som pochopil tak hovoria o tom ze pomocou anotacii (metadat aby som bol presny) sa daju nastavit body rozsirenia pre nejake AOM frameworky (adaptive object model) - ale pride mi to take ako keby hovorilo ze pomocou toho sa to da nakonfiguraovat co mi pride prilis jednoduche.
Na konci pri +  a - je nejaka veta ktora vysveltuje ze anotacie/xml je lepsia ako naming conventisons kvoli couplingu.
Zda sa ze AOM vyuziva metadata vo velkom.
>>>
<<<
aomExtensionPoints
>>>
<<<
Matsumoto, P. M.; Correia, F. F.; Yoder, J. W.; Guerra, E.; Ferreira, H. S. \& Aguiar, A. (2011), 'AOM Metadata Extension Points', in 18th Conference on Pattern Languages of Programs (PLoP), Portland, Oregon, USA, October 2011, pp. 1--16
>>>
<<<
@OP;annotations application;IoC;inversion of control;naming conventions;XML;.NET attributes;Java annotations;navigation;metadata;
>>>

<<<
Annotation Based Parser Generator
>>>
<<<
not so interesting/Annotation Based Parser Generator.pdf;
>>>
<<<
yajco
>>>
<<<
YAJCo
>>>
<<<
Porubän, J.; Forgáè, M.; Sabo, M. \& Bìhálek, M. (2010), 'Annotation Based Parser Generator', in Computer Science and Information Systems, vol. 7, no. 2, 2010, pp. 291--307
>>>
<<<
new;YAJCo;
>>>

<<<
Automatically Optimizing Context Management in Contextual Composition Frameworks
>>>
<<<
D:/attr/not so interesting/Automatically Optimizing Context Management;
>>>
<<<
Clanok o nejakom frameworku, ktory ma automatizovat optimalizaciu systemu vyuzivajuceho kontextovy framework (framework, pri pouzivani ktoreho sluzieb su nejake prepodmienky a prip. aj postpodmienky). Anotacie su tam spomenute len ako moznost konfiguracie frameworku.
>>>
<<<
optContextManagment
>>>
<<<
Trofin, M. (2008), 'Automatically Optimizing Context Management in Contextual Composition Frameworks', in ECOOP 2005, Glasgow, UK, pp. 1--4
>>>
<<<
annotations application;
>>>

<<<
Concepts and Concept-Oriented Programming
>>>
<<<
D:/attr/not so interesting/Concepts and Concept-Oriented Programming;
>>>
<<<
Takmer vobec tomu nerozumiem, ale spomina sa @OP v related works. Takze asi tolko k tomu.
>>>
<<<
conceptsAndCOP
>>>
<<<
Savinov, A. A. (2008), 'Concepts and Concept-Oriented Programming', in Journal of Object Technology, vol. 7, no. 3, pp. 91--106
>>>
<<<
@OP;annotations;competition;
>>>

<<<
Creating software models with semantic annotation
>>>
<<<
D:/attr/not so interesting/Creating software models with semantic annotation;
>>>
<<<
NLP (natural language processing) s pomocou anotovania textu za ucelom vytvaranie modelu - anotovanie textu.
>>>
<<<
creatingSoftModSemAnn
>>>
<<<
Tichy, W. F.; Körner, S. J. \& Landhäußer, M. (2010), 'Creating software models with semantic annotation', in Proceedings of the third workshop on Exploiting semantic annotations in information retrieval, ESAIR '10, ACM, pp. 17--18
>>>
<<<
annotations application;annotations definition;theory;
>>>

<<<
Using Framework Introspection for a Deep Integration of Domain-Specific Models in Java Applications
>>>
<<<
D:/attr/not so interesting/D4F2009_Proceedings;
>>>
<<<
Takmer nic s anotaciami ak som to pochopil, snazia sa poskytnut lepsiu integraciu modelu s implementaciou, prepajat nekontrolovane casti customizacie s modelom.
Model attributes are represented here using annotations [17]. Java annotations are syntactically elegant but only provide very limited automatic consistency checking capabilities. The scope of an annotation only can be restricted to very generic Java constructs as fields, types, methods, and constructors. TheColumnannotation used in the example could also be applied to thesetGroups method, which would be an inconsistent modeling. This inconsistency cannot be checked by the Java compiler. Post-IntelliJ-IDEs cannot provide help answering questions about which modeling attributes are available in a specific situation.
>>>
<<<
deepIntegrationDSM
>>>
<<<
B\"{u}chner, T. \& Matthes, F. (2009), 'Using Framework Introspection for a Deep Integration of Domain-Specific Models in Java Applications', in Design for Future -- Langlebige Softwaresysteme, 1. Workshop des GI-Arbeitskreises 'Langlebige Softwaresysteme (L2S2)', 15. -- 16. October 2009, FZI Forschungszentrum Informatik, Karlsruhe
>>>
<<<
Java annotations;DSL;internal DSL;embedded DSL;MDD;annotations dependency;annotations constraints;annotations unnamed constructs;
>>>

<<<
Data, information and knowledge: have we got it right?
>>>
<<<
D:/attr/not so interesting/datavsinfo;
>>>
<<<
Data, information and knowledge: have we got it 
right?
>>>
<<<
datavsinfo
>>>
<<<
Boisot, M. \& Canals, A. (2004), 'Data, information and knowledge: have we got it right?', in Journal of Evolutionary Economics, vol. 14, no. 1, pp. 43--67
>>>
<<<
metadata;information;data;
>>>

<<<
Design of a Simple and Effective Object-to-Relational Mapping Technique
>>>
<<<
D:/attr/not so interesting/Design of a Simple and Effective Object-to-Relational Mapping Technique;
>>>
<<<
Nejaky novy pristup na definovanie O/RM, z znejakeho dovodu chcu vsetky vztahy ukladat osve a nie do tabuliek pre objekty, pretoze v RD je to vraj naopak nez v OO a to vraj narusuje nieco. Nic s anotaciami.
>>>
<<<
designSimple
>>>
<<<
Lodhi, F. \& Ghazali, M. A. (2007), 'Design of a simple and effective object-to-relational mapping technique', in Proceedings of the 2007 ACM symposium on Applied computing, SAC '07, ACM, pp. 1445--1449
>>>
<<<
ORM;database;
>>>

<<<
Invasive Software Composition
>>>
<<<
D:/attr/not so interesting/invasive software composition - presentation;
>>>
<<<
Invasive composition adapts and extends components at hooks by transforamtion.
declared hooks by component
an invasive composition operator treats declared and implicit hooks uniformly.
na co sa da invasive software composition pouzit?
hodilo by sa pouvazovat o tomto
>>>
<<<
invSoftComposition
>>>
<<<
A\ssmann, U. (2003), 'Invasive software composition', Springer
>>>
<<<
generative programming;invasive software composition;locality;
>>>

<<<
LCLint A Tool for Using Specifications to Check Code
>>>
<<<
D:/attr/not so interesting/LCLint A Tool for Using Specifications to Check Code;
>>>
<<<
Checkuje kod C, pouziva pritom nejaku "konfiguraciu".
>>>
<<<
lclintCheckCode
>>>
<<<
Evans, D.; Guttag, J. V.; Horning, J. J. \& Tan, Y. M. (1994), 'LCLint: A Tool for Using Specifications to Check Code', in SIGSOFT FSE, pp. 87--96
>>>
<<<
type checking;program checking;
>>>

<<<
On the Definition of Patterns for Semantic Annotation
>>>
<<<
D:/attr/not so interesting/On the Definition of Patterns for Semantic Annotation;
>>>
<<<
SRGS standard ktori popisuje ako mapovat ABNF (Augmented) na XML.
semanticke anotacie v tomto pripade su anotacie ku kniham a dokumentom ak som to pochopil, nejake patterny an to.
>>>
<<<
defPatternsSemAnnotations
>>>
<<<
Marrero, M.; Urbano, J.; Morato, J. \& Sánchez-Cuadrado, S. (2010), 'On the definition of patterns for semantic annotation', in Proceedings of the third workshop on Exploiting semantic annotations in information retrieval, ESAIR '10, ACM, pp. 15--16
>>>
<<<
annotations application;annotations definition;theory;
>>>

<<<
Points-to Analysis for Java Using Annotated Constraints
>>>
<<<
D:/attr/not so interesting/Points-to Analysis for Java Using Annotated Constraints;
>>>
<<<
Nieco s anotovanim podmienok ktore pouzivaju pri nejakej analyze pre optimalizaciu kodu, velmi malo spolocneho.
>>>
<<<
pointsToAnalysis
>>>
<<<
Rountev, A.; Milanova, A. \& Ryder, B. G. (2001), 'Points-To Analysis for Java using Annotated Constraints', in SIGPLAN Not., vol. 36, no. 11, October 2001, ACM, pp. 43--55
>>>
<<<
annotations;theory;annotations definition;
>>>

<<<
Using Reflection to Reduce the Size of .NET Executables
>>>
<<<
D:/attr/not so interesting/Using Reflection to Reduce the Size of .NET Executables;
>>>
<<<
Pouziva reflexiu na kompresiu Executablov .NET.
>>>
<<<
cepaExecutables
>>>
<<<
Cepa, V. (2005), 'Using Reflection to Reduce the Size of .NET Executables', in Journal of Object Technology, vol. 4, no. 7, pp. 51--64
>>>
<<<
.NET;reflection;compression;
>>>

<<<
@Composite - Macro Annotations for Java
>>>
<<<
D:/attr/optimization/@Composite - Macro Annotations for Java;
>>>
<<<
@Composite ma sluzit ako kompozicne anotacie, kde anotacia definuje listove anotacie, ktore sa vracaju namiesto kompozitu, pricom kompozit umoznuje nalinkovat factory ktora vrati dynamicky vytvorenu anotaciu.
>>>
<<<
compositeMacroAnnotations
>>>
<<<
Phillips, A. (2009), '@Composite: Macro Annotations for Java', in Proceedings of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications, OOPSLA '09, ACM, pp. 767--768
>>>
<<<
optimization;@OP;attribute-oriented programming;dynamic annotations;theory;dumb;composite annotations;
>>>

<<<
Annotation refactoring: inferring upgrade transformations for legacy applications
>>>
<<<
D:/attr/optimization/Annotation Refactoring Inferring Upgrade Transformations for Legacy Applications;
>>>
<<<
This paper presents a novel refactoring approach that solves both the Version and Vendor Lock-In problems out-lined above. Our approach has three phases: first, the frame-work developer creates representative examples of a class before and after transitioning; second, our algorithm infers generalized transformation rules from the given examples; finally, application developers use the inferred rules to pa-rameterize our program transformation engine, which auto-matically refactors their legacy applications.

Annotation Refactoring? a new class of refactorings that replaces the type and naming requirements of an old framework version or annotation requirements of a dif-ferent framework with the annotation requirements of a target framework.
Potrebhnutelne zmeny:
1. Super type changes
2. Method signature changes
3. Field type changes
4. Annotations added or removed
5. Annotation argument added or removed
6. Imports added or removed
7. Statement added or removed
Viacere strategie odvodenia

idea: myslim ze to aj oni hovoria vo future, ze z xml do ann

Be-ing embedded within the source code next to the program elements they describe, annotations provide declarative in-formation more robustly and concisely.
>>>
<<<
annotationRefactoring
>>>
<<<
@article{annotationRefactoring,
 author = {Tansey, Wesley and Tilevich, Eli},
 title = {{Annotation Refactoring: Inferring Upgrade Transformations for Legacy Applications}},
 journal = {SIGPLAN Not.},
 issue_date = {September 2008},
 volume = {43},
 number = {10},
 month = oct,
 year = {2008},
 issn = {0362-1340},
 pages = {295--312},
 numpages = {18},
 url = {http://doi.acm.org/10.1145/1449955.1449788},
 doi = {10.1145/1449955.1449788},
 acmid = {1449788},
 publisher = {ACM},
 address = {New York, NY, USA},
}
>>>
<<<
naming conventions;@OP;annotations refactoring;superimposition of annotations;inferring;pattern recognition;optimization;transformation;locality;embedded;internal vs external;dumb;type conventions;
>>>

<<<
Daileon: A Tool for Enabling Domain Annotations
>>>
<<<
D:/attr/optimization/Daileon A Tool for Enabling Domain Annotations;
>>>
<<<
Tento clanok mi pripomina ze mozno by som sa vedel nbejako spojit s Miskou a daco stvorit spolocne. Domain modeling*.
"a program-level marking technique that allows developers to annotate pro-gramming elements (i.e. classes and methods) to indicate
application-specific or domain-specific semantics" (citovane z Leveraging component-oriented programming with attribute-oriented programming)
"The use of annota-tions by aspect-oriented frameworks [6] in some cases can reduce significantly the amount of advices and the syntactic coupling [7]. One point to be observed when using annotations in aspect-oriented frameworks is that it breaks part of their obliviousness [5], since classes will contain explicit information about crosscutting concerns."

Snazia sa nahradit klasicke anotacie domenovymi anotaciami - aby oddelili domenovu vrstvu v systeme od infrastruktury.
Daileon framework sa stara o to aby bolo v podstate mozne pouzivat domenove anotacie namiesto infrastrukturnych. Myslienka je, ze ak je framework novy tak sam pristupuje k dolovaniu informacii cez Daileon, pri starych sa pouziva bytecode manipulation aby sa nahradili domenove tymi "normalnymi".

idea: Miskine vystupy presmerovat na anotovanie bussiness vrstvy..
>>>
<<<
daileon
>>>
<<<
Perillo, J. R. C.; Guerra, E. M. \& Fernandes, C. T. (2009), 'Daileon: a tool for enabling domain annotations', in Proceedings of the Workshop on AOP and Meta-Data for Software Evolution, RAM--SE '09, pp. 1--4
>>>
<<<
DSL;domain-specific abstractions;Java annotations;domain modeling;annotations optimalization;annotations definition;Daileon;optimization;idea;dumb;
>>>

<<<
Metadata Modularization Using Domain Annotations
>>>
<<<
D:/attr/optimization/Metadata Modularization Using Domain Annotations;
>>>
<<<
Attribute-oriented programming is a program level marking technique  that  allows  developers  to  mark  programming elements, such as classes and methods, to indicate  applica-tion-specific or domain-specific semantics.
Spomina konfiguracne techniky.
Daileon framework, chcu pouzivat domenove anotacie.
Slo by ho rozsirit o podporu aj XML a inych formatov? Napr. ze XY framework podpourje iba XML tak preco nespravit nieco co umozni taketo nieco? Nie je to BTE? A A2X?
V podstate ide o to ze si definujeme domenove anotacie (nie frameworkove), urcime si ich vyznam mapovanim na frameworkove.
>>>
<<<
metadataDomainAnnotations
>>>
<<<
Perillo, J. R. C.; Guerra, E. M.; Silva, J. O.; Silveira, F. F. \& Fernandes, C. T. (2009), 'Metadata Modularization Using Domain Annotations', in Proceedings of the 3rd Workshop on Assessment of Contemporary Modularization Techniques (ACoM.08), Lancaster University, USA, pp. 29--34
>>>
<<<
annotations definition;@OP;metadata;Java annotations;attribute-oriented programming;naming conventions;Daileon;annotations alternatives;optimization;dumb;
>>>

<<<
A Metadata-Based Components Model
>>>
<<<
D:/attr/theory/A Metadata-Based Components Model;
>>>
<<<
V podstate proposal ich prace v tejto oblasti, Guerra by mal byt teraz uz dost znamy aby som vedel ze o co mu ide. Metadata, metadata, metadata..
>>>
<<<
metadataCompModel
>>>
<<<
Guerra, E. M. \& Fernandes, C. T. (2008), 'A Metadata-Based Components Model', in Proceedings of Doctoral Symposium at 22nd European Conference on Object Oriented Programming, ECOOP '08, pp. 1--4
>>>
<<<
@OP;metadata;attribute-oriented programming;theory;navigation;external metadata;naming conventions;patterns;annotations;annotations definition;
>>>

<<<
A Pattern Language for Metadata-based Frameworks
>>>
<<<
D:/attr/theory/A Pattern Language for Metadata-based Frameworks;
>>>
<<<
A program-level  marking  technique  that allows developers to mark programming elements

Metadata-based frameworks are frameworks that use class metadata in runtime to process their logic

But  in  these  frameworks,  the  metadata  can  be  stored not only by using  annotations,  but  also  by  using  external  files  (usually  as XML  documents),  databases  or  programmatically.  The  metadata can also be configured implicitly using name conventions [6]. 
velmi dobre, metadata patterns, odosobnenie sa od strtegie citania a pod.

VElmi pekne patterns, bude to skvele porovnat s mojou diplomovkou. Tie vzory su vzory navrhu citania metadat - ako navrhovat modul citania metadat a ake tam existuju vzory.
>>>
<<<
patternLanguageMetadata
>>>
<<<
Guerra, E. M.; de Souza, J. T. \& Fernandes, Clovis T. (2009), 'A pattern language for metadata-based frameworks', in Proceedings of the 16th Conference on Pattern Languages of Programs, PLoP '09, ACM, art. 3, pp. 1--29
>>>
<<<
@OP;metadata;attribute-oriented programming;theory;navigation;external metadata;naming conventions;@OP vs XML;patterns;annotations;annotations definition;
>>>

<<<
A Simple Edit-Time Metaobject Protocol
>>>
<<<
D:/attr/theory/A Simple Edit-Time Metaobject Protocol;
>>>
<<<
Navrhuju pouzit nejaky edit-time metaobject protocol na prehladnejsie zobrazovanie anotacii v kode.
>>>
<<<
simpleEditTimeMOP
>>>
<<<
Eisenberg, A. D. \& Kiczales, G. (2006), 'A simple edit-time metaobject protocol: controlling the display of metadata in programs', in Companion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications, OOPSLA '06, ACM, pp. 696--697
>>>
<<<
theory;@OP;attribute-oriented programming;annotations;presentation;annotations usage;metaobject protocol;views;
>>>

<<<
Architectural Patterns for Metadata-based Frameworks Usage
>>>
<<<
D:/attr/theory/Architectural Patterns for Metadata-based Frameworks Usage;
>>>
<<<
Opat patterns, ale tieto su patterny pouzitia skor by som povedal.
aj naznak riesenia ze kedy je lepsie anotacie a kedy XML.
Mapping pattern, and so on...
Najme je to podla mna o tom, na co sa daju metaudaje pozutit

Using   this   approach,   the   framework,   and   not   the application, is responsible for the main execution flow. This is also known as the Hollywood Principle: ?don't call us, we'll call you?.

Metadata is an overloaded term in computer science and can be interpreted differently according to the context. In the context of object-oriented programming, metadata is information about the program structure itself such as classes, methods and attributes. A class,   for   example,   has   intrinsic   metadata   like   its   name,   its superclass, its interfaces, its methods and its attributes.

The   metadata   consumed   by   the   framework   can   be   defined   in different ways. Naming conventions [4] uses patterns in the name of   classes   and   methods   that   has   a   special   meaning   for   the framework.

Conventions usage can save a lot of configurations but it has a limited expressiveness. For some scenarios the metadata needed are more complex and naming conventions are not enough.

Another option is the metadata definition in external sources, like XML files and databases. The possibility to modify the metadata at deploy-time or even at runtime without recompile the code is an advantage of this type  of definition.  However, the definition is more verbose because it  has to reference and identify program elements.   Furthermore,   since   the   class   definition   and   metadata configuration are in separate files, the distance between them is increased, which may be not intuitive for some developers.

Another   alternative   that   is   becoming   popular   in   the   software community is the use of code annotations, that is supported by some programming languages like Java [11] and C# [12]. Using this technique the developer can add custom metadata elements 
directly into  the  class source  code, keeping  this definition  less verbose   and   closer   to   the   source   code.   The   use   of   code annotations is called attribute-oriented programing [14].

idea: ako metadata vplyvaju an design patterns? je ich mozne nahradti/simulovat metaudajmi?
>>>
<<<
architecturalPatternsGuerra
>>>
<<<
Guerra, E.; Fernandes, C. \& Silveira, F. F. (2010), 'Architectural Patterns for Metadata-based Frameworks Usage', in Proceedings of the 17th Conference on Pattern Languages of Programa, PLoP2010, Reno, Nevada. USA, pp. 1--25
>>>
<<<
@OP;metadata;attribute-oriented programming;theory;navigation;external metadata;naming conventions;@OP vs XML;patterns;annotations;inversion of control;annotations application;internal vs external;idea;
>>>

<<<
Domain Annotations
>>>
<<<
D:/attr/theory/Domain_Annotations;
>>>
<<<
keywords; marker interfaces; formatted comments; naming conventions
when they should be used
>>>
<<<
domainAnnotations
>>>
<<<
Doernenburg, E. (2008), 'Domain Annotations', in THE THOUGHTWORKS anthology: essays on software technology and innovation. Raleigh: Pragmatic Bookshelf, Chapter 10, pp. 121--141
>>>
<<<
Java annotations;@OP;.NET attributes;annotations theory;competition;alternatives;usage;domain annotations;semantic annotations;documenting annotations;external vs internal;
>>>

<<<
Domain Annotations 2
>>>
<<<
D:/attr/theory/Domain_Annotations_GIDS;
>>>
<<<
co pouzit ako metadata techniku, kedy ich vobec pouzit
>>>
<<<
domainAnnotations2
>>>
<<<
Doernenburg, E. (2008), 'Domain Annotations', in THE THOUGHTWORKS anthology: essays on software technology and innovation. Raleigh: Pragmatic Bookshelf, Chapter 10, pp. 121--141
>>>
<<<
.NET attributes;alternatives;competition;usage;
>>>

<<<
How .NETs Custom Attributes Affect Design
>>>
<<<
D:/attr/theory/How .NETs Custom Attributes Affect Design;
>>>
<<<
a defined method for adding declarative information (metadata) to runtime entities in the platform.

Attributes in .NET provide an ele-gant, consistent approach toadding declarative information toruntime entities. Because the runtime entities interact with the supporting services via declarative information, the set of services and supporting at-tributes does not have to be closed.

V podstate ukazuju ako su anotacie lepsie nez napr marker interfaces a naming conventions.

In its first release of the .NET Frame-work, Microsoft has provided a de-fined method for adding declarative in-formation (metadata) to runtime enti-ties in the platform. These entities in-clude classes, methods, properties, and
instance or class variables.
>>>
<<<
dotNetAttDesign
>>>
<<<
@ARTICLE{dotNetAttDesign, 
author={Newkirk, J. and Vorontsov, A.A.}, 
journal={Software, IEEE}, 
title={{How .NET's custom attributes affect design}}, 
year={2002}, 
month={Sept}, 
volume={19}, 
number={5}, 
pages={18-20}, 
doi={10.1109/MS.2002.1032846}, 
ISSN={0740-7459},}
>>>
<<<
@OP;attribute-oriented programming;annotations;.NET attributes;marker interfaces;alternatives;competition;naming convention;theory;
>>>

<<<
Idioms for Code Annotations in the Java Language
>>>
<<<
D:/attr/theory/Idioms for Code Annotations in the Java Language;
>>>
<<<
Annotations  are  declarative  constructs  used  to  add  specific  semantics  to  code  elements such as  classes,  methods,  attributes, and other  annotations.  Their  mostly common  uses  provide  information  for:  compilers  about the  program;  software  tools  to  generate code or XML files; the application at runtime. This paper focuses on the use of annotations at runtime.

VECTORIAL ANNOTATION - vektor anotacii ak je treba viacero
COMPOSITE ANNOTATION - hovori samo za seba, proste vyskladana anotacia
WELL-FORMED EXPRESSION - String value, kde sa vklada v podstate nejaky novy jazyk
ASSOCIATIVE ANNOTATION - asociuje pomocou atributu typu class triedu k anotovanemu elemntu, dokazeme vybavit typovu bezpecnost
INFERRED METADATA - default metadata odvodene podla niecoho
GENERAL CONFIGURATION - jedna hlavna anotacia napr nad triedou, a ta sa "dedi" na ine elementy, s tym ze ked ju treba prekryt tak sa pouzije - motivacia, ak sa vela anotacii opakuje v triede (ale neda sa pouzit inferred metadata)
ANNOTATION MAPPING - o tomto je daileon
ANNOTATION READER - anotacny vzor na rozsirenie anotacnej schemy, metaanotcia povie ktory anotacny typ rozsiruje schemu frameworku a ktora trieda (reader) ju spracuva (v podstate pouziva vzor associative annotation)


Custom annotations can represent domain concepts, reducing the number of infrastructure-related annotations in domain classes.
>>>
<<<
idiomsAnnotations
>>>
<<<
Guerra, E.; Cardoso, M.; Silva, J. \& Fernandes, C. (2010), 'Idioms for Code Annotations in the Java Language', in 17th Latin-American Conference on Pattern Languages of Programs, SugarLoafPLoP, Salvador, Bahia, Brazil (October 16--18 2010), pp. 1--14
>>>
<<<
@OP;Java annotations;attribute-oriented programming;annotations usage;annotating unnamed elements;annotations patterns;domain-specific concepts;theory;annotations definition;
>>>

<<<
Instrumenting Annotated Programs
>>>
<<<
D:/attr/theory/Instrumenting Annotated Programs;
>>>
<<<
Popisuje napr na co sa anotacie daju pouzit.
Instrumentation moze narusit semantiku anotacii.
Klasifikuju anotacie podla ich spravania sa pri instrumentacii. Popis instrumentacie.
Indicative - oznamuju nejaky fakt o kode
Imperative - prikazy pre nejaky tool, generator
Subjunctive - poziadavka na kod, ktora moze a nemusi byt dodrzana
DObre odkazy pri deleni
navrhuju definovat kam spada anotacia aby sa podla toho mohli instrumentacne programy spravat - definovat pomocou metaanotacii

Program annotations are information passed by application developers or tools to the virtual runtime so as to specialize or tailor the execution characteristics of the application.

Pragmas were an early incarnation of metadata annota-tions,passing information from the programmer to the build tools. Other tools used source-file annotations (appearing ei-ther as new keywords or as specially-formatted comments) to receive hints from the programmer,for example,variable mutation and aliasing information [10,1,23]. Annotations guide compilers in concurrent code generation [21,3] and declare method pre- and post-conditions [14,16].

of Java,an attribute was a byte array of known length and unknown semantics attached to a class file element,e.g., the class itself,fields,methods,or code arrays. A virtual machine is required to silently ignore all attributes that it does not recognize,and the attributes are prohibited from affecting the semantics of Java types.
>>>
<<<
instrAnnotPrograms
>>>
<<<
Biberstein, M.; Sreedhar, V. C.; Mendelson, B.; Citron, D. \& Giammaria, A. (2005), 'Instrumenting annotated programs', in Proceedings of the 1st ACM/USENIX international conference on Virtual execution environments, VEE '05, ACM, pp. 164--174
>>>
<<<
@OP;attribute-oriented programming;annotations usage;annotations application;annotations classification;instrumentation;history;annotations definition?;Java annotations;.NET attributes;theory;annotations definition;
>>>

<<<
Introduction and Derivation of Annotations in AOP
>>>
<<<
D:/attr/theory/Introduction and Derivation of Annotations in AOP;
>>>
<<<
The concept of annotations has been introduced recently in various programming languages, such as Java[14] and C# [7], to enable the attachment of meta-data to program el-ements.
Annotations can be used to express design intentions and semantic properties of program elements.
In [13], it was pointed out that naming conventions, marker interfaces and other techniques are used in practice to ex-press meta-date in the absence of support for annotations.
Zaujimavy pohlad, namiesto chytania sa na anotacie (teda nie doslova namiesto, ale otacaju to) sa na naviazane joinpointy vkladaju anotacie (najma za ucelom vkladania a derivovania anotacii, ktore nejako suvisia od inych, na tie sa naviazu a a derivuju od nich zavisiace.).
Potom je tam velky pokec o tom ake pri tom mozu vzniknut problemy.
>>>
<<<
introductionDerivationAnnAOP
>>>
<<<
Havinga, W.; Nagy, I. \& Bergmans, L. (2005), 'Introduction and Derivation of Annotations in AOP: Applying Expressive Pointcut Language to Introductions', in European Interactive Workshop on Aspects in Software, 2005, pp. 1--8
>>>
<<<
@OP;AOP;annotations application;annotations definition;semantic annotations;documenting annotations;marker interfaces;naming conventions;navigation;theory;superimposition of annotations;locality;design intentions;dumb;
>>>

<<<
Programming C#: Chapter 18, Attributes and Reflection
>>>
<<<
D:/attr/theory/Print - ONDotNet.com_ Programming C#_ Attributes and Reflection;
>>>
<<<
An attribute is an object that represents data you want to associate with an element in your program. The element to which you attach an attribute is referred to as the target of that attribute.
intrinsic and custom attributes - podobne je v jave
Attribut ako strukturovany komentar
A zda sa ze sa daju pouzit viacere rovnake atributy nad jeden kus kodu; dokonca sa da ovedat ci to ma alebo nema byt mozne!
>>>
<<<
programmingCSharpCh18
>>>
<<<
Liberty, J. (2001), 'Attributes and Reflection', in Programming C\#, Chapter 18, O'Reilly, 680 pages
>>>
<<<
annotations definition;attribute-oriented programming;@OP;.NET attributes;classificiation;theory;
>>>

<<<
Quality Improvement in Annotated Code
>>>
<<<
D:/attr/theory/Quality Improvement in Annotated Code;
>>>
<<<
Attribute-oriented programming is a program-level marking technique used to mark program elements, such as classes, methods and attributes, to indicate that they maintain application-specific or domain-specific semantics.

The  metadata  consumed  by  a  framework  or  a  tool  can  be  defined  in  different  ways.  It  can  be  defined  inside  the application  class,  by  using  code  annotations  or  code  conventions.  Moreover,  it  can  be  defined  by  external  sources, through the use of XML documents or databases.

Robia metriky k tomu ze ako pouzivat anotacie, ci ich nie je privela a pod.
Ak sa to deteguje, navrhuju riesit problem refaktorizaciou, a to bud presunutim conf. do externeho suboru, alebo naming conventions (co vsak zmeni konfiguraciu z explicitnej an implicitnu), vseobecnu konfiguraciu (tj zgrupit viacero do jednej v rodicovi), default value, resp. refactoring anotacnej schemy, ci pouzitie domenovych anotacii a ich mapovanie na frameworkove

predstavuju annotation sniffer plugin, ktory automaticky pocita ich metriky
>>>
<<<
qualityAnnotated
>>>
<<<
Correia, D. A. A.; Guerra, E. M.; Silveira, F. F. \& Fernandes, C. T. (2010), 'Quality Improvement in Annotated Code', in CLEI Electronic Journal, vol. 13, no. 2, art. 7, August 2010
>>>
<<<
Metadata;Attribute-Oriented Programming;Code Annotations;Metrics;@OP;annotations definition;domain specific abstractions;internal vs external;theory;annotations usage;naming conventions;
>>>

<<<
Representing Explicit Attributes in UML
>>>
<<<
D:/attr/theory/Representing Explicit Attributes in UML;
>>>
<<<
nedalo by sa AOP pouzit na checkovanie dependecies?

AOP techniques have been usually used to enable horizon-tal transformations (within the same meta-model) in program-ming languages [14]. Attributes can carry custom semantics and can be used either for horizontal, or for vertical (mapping between different meta-models) transformations.

Pozretie sa na UML:
tagged values - kluc=hodnota - oproti @OP nie su strukturovane, nie je mozne ich odlisit od inych tagged values (att vs tv)

kritika: http://www.riedquat.de/blog/2007-12-15-01
>>>
<<<
representingAttUML
>>>
<<<
Cepa, V. \& Kloppenburg, S. (2005), 'Representing Explicit Attributes in UML', in 7th International Workshop on Aspect-Oriented Modeling
>>>
<<<
@OP;Java annotations;alternatives;annotations usage;competition;attribute-oriented programming;idea;dependency;fragile pointcut;AOP;generative programming;transformations;UML;competition;@OP vs AOP;
>>>

<<<
XML, Annotations and Database: a Comparative Study of Metadata Definition Strategies for Frameworks
>>>
<<<
D:/attr/theory/xata - Copy;
>>>
<<<
To co to hovori, analyzuje v troch scenaroch co je lepsie ako format pre konfiguraciu (pre metadata). Pekne celkom a myslim ze vhodne.
>>>
<<<
XMLAnnotationsDataB
>>>
<<<
Fernandes, C.; Ribeiro, D.; Guerra, E. \& Nakao, E. (2010), 'XML, Annotations and Database: a Comparative Study of Metadata Definition Strategies for Frameworks', in XATA 2010: XML, Associated Technologies and Applications, May 19--20, Vila do Conde, Porto, pp. 115--126
>>>
<<<
annotations;@OP;theory;attribute-oriented programming;database;naming conventions;metadata;metadata format;annotations usage;annotations vs XML;@OP vs XML;external metadata;internal metadata;
>>>

<<<
Parsing XML Documents in Java using Annotations
>>>
<<<
D:/attr/theory/xata;
>>>
<<<
Event based XML parser pomocou anotacii. Niekde som o niecom takom cital (skontroluj ked budes mat cas).
Ale robia to runtime, tamti to robili generativne, mozno by sa na tom nieco dalo postavit.
>>>
<<<
parsingXMLAnnotations
>>>
<<<
Nuccitelli, R.; Guerra, E. \& Fernandes, C. (2010), 'Parsing XML Documents in Java using Annotations', in XATA 2010: XML, Associated Technologies and Applications, May 19--20, Vila do Conde, Porto, pp. 103--114
>>>
<<<
XML;Java annotations;annotations application;@OP;metadata;
>>>

<<<
Aspect-Oriented Programming is Quantification and Obliviousness
>>>
<<<
D:/attr/theory/AOP/Aspect-Oriented Programming is Quantification and Obliviousness;
>>>
<<<
The first exceptions to locality were subprograms ( i.e., procedures, subroutines, functions.) Subprograms were a great invention, enabling abstracting out some behavior to someplace else.
Inheritance in object-oriented programming (OOP) was the second important introduction of non-locality. Executing inherited behavior is non-local. There are two different fashions of inher-iting behavior, send super and mixins. Send-super systems like Java and Smalltalk allow the programmer to explicitly invoke the be-havior of its parent class or classes, without knowing exactly what behavior is being invoked.
We want to be able to say, ? This code realizes this concern. Execute it whenever these circum-stances hold.?  This breaks completely with local and unitary demands ?we can organize our pro-gram in the form most appropriate for coding and maintenance.

Staticka kvantifikacia (co vieme specifikovat ako podmienku vazby)
	Black box AOP - v?zba na komponenty, ich wrapovanie
	Clear box - moznost jemnozrnejsieho viazania sa, pristup ku kodu
Dynamicka kvantifikacia
	vazba na dynamicky content - na control flow/data flow (napr vyvolanie vynimky)

AOP Jazyk
	Rule-based systems.  Rule-based systems like OPS-5 [4] or, to a lesser extent, Prolog are programming with purely dynamically quantified statements.
	Event-based, publish and subscribe. In EBPS systems, the subscription mechanism is precisely a quantification mechanism. ( ? Let me know whenever you see something like ??).
	Intentional Programming and Meta-programming . Intentional programming (IP) [1] and meta-programming (MP) [12] provide the ability to direct the execution order in arbitrarily defined computational patterns.
	Generative Programming.  Similarly, generative programming [6] works by transforming higher-level representations of programs into lower-level ones (that is, by compiling high-level specifications.)

AOP is not about OOP
AOP is not useful for singletons
Better AOP systems are more oblivious.  They minimize the degree to which pro-grammers (particularly the programmers of the primary functionality) have to change their behavior to realize the benefits of AOP.
>>>
<<<
quantObliviAOP
>>>
<<<
Filman, R. \& Friedman, D. (2000), 'Aspect-Oriented Programming is Quantification and Obliviousness', in Proc. Workshop on Advanced Separation of Concerns, OOPSLA 2000, October 2000
>>>
<<<
AOP;locality;localization;position;procedures vs code;AOP theory;theory;internal vs external;AOP language;
>>>

<<<
Bridging Java and AspectJ through Explicit Join Points
>>>
<<<
D:/attr/theory/AOP/Bridging Java and AspectJ through Explicit Join Points;
>>>
<<<
Je to trosku debilne postavene podla mna, ale naznacuje to to co som si myslel, explicitne joinpointy - explicitne ja nastavujem co chcem aby tu bolo vkladane, aky aspekt. Je to teda podobne ako je to s AOP s anotaciami, ale namiesto anotacii pouzivam kod.
Idea: ked sa viazem na anotacie, su tie anotacie explicitne na aspekty, resp su to domenove anotacie? Mozno nieco s Daileonom by sa dalo spravit.
>>>
<<<
explicitJoinPoints
>>>
<<<
Hoffman, K. J. \& Eugster, P. (2007), 'Bridging Java and AspectJ through explicit join points', in Proceedings of the 5th international symposium on Principles and practice of programming in Java, PPPJ '07, ACM, pp. 63--72
>>>
<<<
idea;AOP;@OP;alternative;theory;navigation;fragile pointcut;attribute-oriented programming;internal vs external;
>>>

<<<
Domain-Specific Languages and Program Generation with Meta-AspectJ
>>>
<<<
D:/attr/theory/AOP/Domain-Specific Languages and Program Generation with Meta-AspectJ;
>>>
<<<
MetaAspectJ ako generator AspectJ, popisovany jazyk, argumentuju za pouzitie anotacii ako DSL rozsirenie jazyka.

A common pattern of using MAJ is for implementing domain-specific lan-guage extensions using unobtrusive annotations. Recently, the introduction of user-defined annotations in mainstream programming languages, such as C# and Java, has allowed specialized language extensions (e.g., for distributed computing, persistence, or real-time programming) to be added without chang-ing the base syntax. This is a desirable property as it clearly separates the base code from the domain-specific extensions and their implementation.

Ak som ten MAJ pochopil, tak vlastne pre anotacie nedogenruva kod, ale vygeneruje aspekt ktory ten kod doplna weavovanim (good idea!).
Spominaju tam nejaky GOTECH, ktory bol predtym spraveny pocmocou XDcolet. - GOTECH generuje nieco podla anotacii ak som to pochoil, terazto ho prerobili pomoou MAJ.
Pekne odovodnenie preco to robia cez AOP, AOP nie je take finegrained, ale zasa je omnoho jednoduchsie generovat kod takto ako parsovat cely kod a upravovat ten. Je to ako konkurenicia Spoonu.
SPominaju samozrejme aj moznost vazby aspectJ na anotacie.
>>>
<<<
metaaspectJgenerator
>>>
<<<
Huang, S. S.; Zook, D. \& Smaragdakis, Y. (2008), 'Domain-specific languages and program generation with meta-AspectJ', in ACM Trans. Softw. Eng. Methodol., vol. 18, no. 2, art. 6, pp. 1--32
>>>
<<<
AOP;@OP;attribute-oriented programming;annotations application;DSL;MDD;software product line;MetaAspectJ;xDoclet;theory;navigation;fragile pointcut;
>>>

<<<
Improve Pointcut Definitions with Program Views
>>>
<<<
D:/attr/theory/AOP/Improve Pointcut Definitions with Program Views;
>>>
<<<
Namiesto v?zby priamo na kod sa viazu pointcutmi na nejake program views, ktore definuju moduly a messages, vraj tym vedia zabezpecit napr ak view nedefinuje ze sa metody v danom module aj volaju aj poskytuju, tak sa napr na ne v danom module neda naviazat - treba definovat aj volajucu aj volanu stranu aby to bolo mone. Ktovie v com vsetko toto pomoze.
V podstate pomocou views vedia robit viac fine-grained pointcuty.
Injektuju aj anotacie.
>>>
<<<
improvePointcutsAOP
>>>
<<<
Yang, Z. \& Zhao, T. (2007), 'Improve pointcut definitions with program views', in Proceedings of the 5th workshop on Software engineering properties of languages and aspect technologies, SPLAT '07, ACM, art. 9, pp. 1--7
>>>
<<<
AOP;@OP;attribute-oriented programming;annotations application;fragile pointcut;theory;naming conventions;superimposition of annotations;dumb;
>>>

<<<
Role Annotations and Adaptive Aspect Frameworks
>>>
<<<
D:/attr/theory/AOP/Role Annotations and Adaptive Aspect Frameworks;
>>>
<<<
Hovori o probleme krehkych pointcutov, ktore vznikaju pri v?zbe na vymenovanie resp. naming conventions a spomina anotacie ako riesenie tohto problemu. Nasledne vsak ukazuje ze su situacie kedy to nestaci a vyuziva parametre anotacii na parametreizovanie adviceov. To vsetko pre tvorbu AOP frameworkov. Prakticky generuju advices (poiontcuts) pre rozne moznosti parametrov.
>>>
<<<
annotationsAAF
>>>
<<<
Seiter, L. M. (2007), 'Role Annotations and Adaptive Aspect Frameworks', in Proceedings of the 3rd workshop on Linking aspect technology and evolution, LATE '07, ACM, 3, pp. 1--5
>>>
<<<
method listing;AOP;@OP;attribute-oriented programming;annotations application;naming conventions;navigation;theory;fragile pointcut;
>>>

<<<
Separation of concerns through semantic annotations
>>>
<<<
D:/attr/theory/AOP/Separation of concerns through semantic annotations;
>>>
<<<
V podstate clanok o tom ze anotacie pomozu v AOP, navrh.
>>>
<<<
socSemanticAnnotations
>>>
<<<
Cachopo, J. (2002), 'Separation of concerns through semantic annotations', in Companion of the 17th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications, OOPSLA '02, ACM, pp. 2--3
>>>
<<<
strong coupling;navigation;method listing;AOP;fragile pointcut;semantic annotations;SoC;separation of concerns;
>>>

<<<
Separation of Concerns with Procedures, Annotations, Advice and Pointcuts
>>>
<<<
D:/attr/theory/AOP/separationofconcerns;
>>>
<<<
procedure calls bind program points to operations, annotations bind attributes to program points; pointcuts bind sets of points to various descriptions of those sets; named pointcuts bind attributes to sets of points; and advice bind the implementation of an operation to sets of points

check the bibliography for good literature

Straw-Man - priamo vlozeny kod
good old-fashioned procedure (GOFP) - implemetuje staticku proceduru, ktoru vola na zriesenie concernov (refresh na display)
Annotation-Call - anotacia @RefreshDisplay + advice (alebo generator) - anotacia hovori, ze metoda ma refresnut display
Annotation-Property - tuto anotacia hovori ze metoda ma vlastnost menenia displaya (rozdiel len nazov anotacie @DisplayStateChange )
Anonymous-Enumeration-Pointcut - vymenovanie metod ktore maju refresnut display - ale pouziva anonymny pointcut
Named-Enumeration-Pointcut - to iste ale s pomenovanym pointcutom
Named-Pattern-Pointcut - opat pomenovany, ale pozuiva naming convention na pattern

locality of implementation, degree to which the implementation is explicit rather than implicit, and locality of change in a simple evolution experiment

explicity - ze je concern axplicitne definovany
locality - lokalizovany na jednom - resp. konecnom statickom pocte miest (advice)

Name matters - mozno uzitocne - definovat vlasnost kodu, teda to suvisi s documentaciou

So the effect of using a procedure ? a declaration and one or more calls to it ? is to introduce an explicit operation (the procedure), bindings from points in the program to the operation (calls), and a binding from the operation to the implementation (the declaration).

In discussing the relation between annotations and pointcuts, we use the following terminology: Annotations  are the syntactic identifiers described by JSR-175 [4] that the programmer places in the program (i.e. @DisplayStateChange). Properties are the characteristics of points on which pointcuts can match, including class and method names, access modifiers etc.  Pointcut names  are the programmer defined names for pointcuts. We use the term attribute to include both annotations and pointcut names. In other words, attributes are user-defined names that can be attached to program points.

If an operation is needed at a given set of points then using advice and pointcuts serves to make the binding from the set to the operation explicit and local.

If a set of points used in an advice has a common attribute, then using a named pointcut or an annotation can make that common attribute explicit.

Prefer enumeration-based pointcuts when: (i) it is difficult to write a stable property-based pointcut to capture the members and (ii) the set of points is relatively small. 
Prefer property- or pattern-based  pointcuts when: (i) it is possible to write one that is stable or (ii) the set of points is relatively large (more than ten). 
Use  annotations to mark points when three things are true: (i) it is difficult to write a stable property-based pointcut to capture the points, (ii) the name of the annotation is unlikely to change, and (iii) the meaning of the annotation is an inherent to the points, rather than a context-dependent aspect of the points only true in some configurations. 
In addition, lean towards annotations when the property that defines inclusion in the set is an inherent property of the points, and lean towards other  pointcuts when the binding from points to the set might change non-locally, or come into existence non-locally.
>>>
<<<
socProcAnnAdvPoi
>>>
<<<
@inproceedings{socProcAnnAdvPoi,
 author = {Kiczales, Gregor and Mezini, Mira},
 title = {{Separation of Concerns with Procedures, Annotations, Advice and Pointcuts}},
 booktitle = {Proceedings of the 19th European Conference on Object-Oriented Programming},
 series = {ECOOP'05},
 year = {2005},
 isbn = {3-540-27992-X, 978-3-540-27992-1},
 location = {Glasgow, UK},
 pages = {195--213},
 numpages = {19},
 url = {http://dx.doi.org/10.1007/11531142_9},
 doi = {10.1007/11531142_9},
 acmid = {2144904},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}
>>>
<<<
@OP;AOP;external vs internal;position;method listing;naming convention;locality;procedures vs code;theory;SoC;separation of concerns;annotations definition;attribute as annotations and pointcuts;documenting annotations;
>>>

<<<
Statement Annotations for Fine-Grained Advising
>>>
<<<
D:/attr/theory/AOP/Statement Annotations for Fine-Grained Advising;
>>>
<<<
Heterogenne zaujmy si vraj vyzaduju lokaciu joinpointov uprostred metod. Jednou cestou bolo pouzitie dummy method calls.
Oni navrhuju pouzitie statement annotations ako riesenie, to je presne dovod pre ktory to moze mat vyznam.
Okrem dovodu fine-grained advising udavaju dalsie:
Optimization - guide parallelization as in OpenMP; plus dalsie ale tie nedavaju moc zmysel, narp Debugging and fault isolation - nieco re debugger;
Uvadzaju logging ako priklad heterogenneho zaujmu, ktory si ziada viazanie jemnejsieho zrna
>>>
<<<
statementAnnotations
>>>
<<<
Eaddy, M. \& Aho, A. V. (2006), 'Statement Annotations for Fine-Grained Advising', in Proceedings of RAM--SE 06--ECOOP 06 Workshop on Reflection, AOP, and Meta-Data for Software Evolution, Nantes, France, July 4, 2006, pp. 89--99
>>>
<<<
@OP;AOP;attribute-oriented programming;annotating unnamed constructs;statement annotations;
>>>

<<<
Tackling Pointcut Fragility with Dynamic Annotations
>>>
<<<
D:/attr/theory/AOP/Tackling Pointcut Fragility with Dynamic Annotations;
>>>
<<<
Anotaciami pri pointcute vieme oddelit pointcut od struktury kodu. Oni tvrdia ze to nemusi stacit, lebo dynamicke casti pointcutov sa nedaju zachytit a preto navrhuju dynamicke anotacie.
Cez ne proste dokazu vyhodnotit aj nieco viac nez len staticku cast, ale aj nieco ohladom vlastnosti targetu (v prenesenom slova zmysle umoznuju pridavat do anotacii ako keby dynamicky kod ktory je vyhodnocovany pri ich pouziti - tj v tomto pripade pri naviazani sa na ne).

klasifikacia akurat tak na dynamicke a staticke
>>>
<<<
dynamicAnnotationsNoguera
>>>
<<<
Noguera, C.; Kellens, A,; Deridder, D. \& D'Hondt, T. (2010), 'Tackling Pointcut Fragility with Dynamic Annotations', in Proceedings of the 7th Workshop on Reflection, AOP and Meta-Data for Software Evolution, RAM-SE '10, ACM, pp. 1--6
>>>
<<<
fragile pointcut;AOP;@OP;annotations application;naming conventions;navigation;annotations classification;dynamic annotations;
>>>

<<<
The Paradoxical Success of Aspect-Oriented Programming
>>>
<<<
D:/attr/theory/AOP/The Paradoxical Success of Aspect-Oriented Programming;
>>>
<<<
VElmi lahko sa to cita a je to zaujimave.
Naraza na to ze AOP ide prave proti modularite, lebo aspekty zvycajne narazaju na nejaky kontext (v programe do ktoreho su vtkavane) a do neho zasahuju - maju k nemu prisup.. A to vraj nie je v sulade s modularitou.
Udava definiciu, vela cituje Filmana and Friedmana - obliviousness - Program P nevie o concernoch ktore su vtkavane, quantification - vazba na condition C: In programs P, whenever condition  C arises, perform action A.
Obliviousness basically implies that a program has no knowledge of which aspects modify it where or when, and quantification expresses the fact that an aspect can affect arbitrarily many different points in a program.

idea: co takto pouzit AOP na adapter vzor? nieco je modularne ale potrebujem to pouzit na svoj pripad a ten je nejako specifickejsi.. (teraz ma napada ze inheritence je na to..
idea2: porovnat anotacie s volaniami procedur - je v tom v konecnom dosledku rozdiel?

This is an interesting constructi on, since it shows that quantifica-tion can indeed be completely i ndependent from obliviousness: all places where condition  C can possibly arise are explicitly marked in the program text. - procedures
TYmto ukazuje ako sa da natahovat definicia C - bud to C explicitne definujem (volanie proc), alebo mozem C dokonca dat na nahodou - a to uz program nema sajnu co sa deje okolo.

Dalej uvadza ze namiesto explicitneho volania sa mozu miesta s podmienkou C viazat na nejake specificke objekty B ktore su explictne pouzite (npar. anotacie) - to redukuje obliviousness (programator moze vedome vynechat ref. na objekt B aby zabranil vstupu aspektu).

For instance, with trac-ing as a crosscutting concern,  annotating every program element whose execution is to be traced is  just as annoying as adding the tracing code (usually no more than the calling of a subroutine) on site. To avoid this, it has been  suggested to use so-called annota-tor aspects that annotate program el ements so that they can be ad-vised by other aspects [39], as expressed by
In programs P, wherever condition  C arises, add annotation B.

Co sa tyka kvantifikacie, nahodonst je z oboch stran - program nevie kde sa moze aspokt vyvolat, a aj aspektovy programator nemusi mat jasno v tom, ktore vsetky miesta aspekt zasahuje - iba ak ich vymenuje: In programs P, whenever execution reaches one of the points in {p1,?,pn}, perform action A. - fragile pointcut

Prakticke problemy:
MODULARITY - podla Parnasa je to information hiding, pekna fil. rozprava o tom..

	my main concern is the ex-istence of a strong coupling between  an aspect and its target, par-ticularly if this coupling is left im plicit, that is, not reflected in an explicit interface; since this impairs independent development.
when code is moved out of its context to some other place, it must take (a reference to) the context that it depends on with it, thereby es-tablishing a coupling between its old and its new location.

	But as far as  I can see, modularity problems of this kind can only be solved by introducing units larger than sin-gle objects (or their classes) as modules. Splitting a class into a class and an aspect produces sm aller, strongly coupled units; it leads to more and larger interfaces, which is counterproductive to improving modularity.

	Dalsi problem je ze AOP ma skor implicitne nez explicitne rozhrania - a to ide proti indenpedent development. taktiez tu nie je jasny koncept pozadovaneho a poskytovaneho rozhrania (required and provided).

	This  reflects the ?inversion of depend-ency? [49] so characteristic of AOP: technically, although the as-pect complements the target program, the aspect depends on the target and not vice versa.

ORGANIZATION OF SOURCE CODE
	In fact, as has been pointed out in ?AOP consid ered harmful? [13], AOP intro-duces a modern variant of the  comefrom  statement, which was once suggested as a humorous contribution to the goto discus-sion, the joke being that such an inverse form of calling?very much like the implicit invocation mechanisms of AOP [20]?renders even small programs completely unreadable [9].
	AOP adds another dimens ion of not knowing what just happened, or where I have come from, to programming.

GLOBALIZATION OF LOCAL VARIABLES - aspect globalizuje premenne target (base) programu.

Odporuca pouzivat pri generovani (ako generovany, nie generujuci program), pri komponentovom programovani na upravu rozhrani (moja idea vyssie),
>>>
<<<
paradoxAOP
>>>
<<<
Steimann, F. (2006), 'The paradoxical success of aspect-oriented programming', in Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications, OOPSLA '06, ACM, pp. 481--497
>>>
<<<
idea;AOP;modularity;procedures vs pointcuts;fragile pointcut;listing methods;inversion of dependency;
>>>

<<<
Using Aspect-Orientation to Simplify Concurrent Programming
>>>
<<<
D:/attr/theory/AOP/Using Aspect-Orientation to Simplify Concurrent Programming;
>>>
<<<
Principialne je clanok o pouziti AOP v subeznom programovani - a to pocmocou anotacii.. chvalia to..
Pekna analyza kritiky AOP.
>>>
<<<
aoSimConcurrent
>>>
<<<
Hohenstein, U. D. \& Gleim, U. (2011), 'Using aspect-orientation to simplify concurrent programming', in Proceedings of the tenth international conference on Aspect-oriented software development companion, AOSD '11, ACM, pp. 29--40
>>>
<<<
AOP;@OP;attribute-oriented programming;AspectJ;annotations application;generative programming;
>>>

<<<
Utilizing Design Information in Aspect-Oriented Programming
>>>
<<<
D:/attr/theory/AOP/Utilizing Design Information in Aspect-Oriented Programming;
>>>
<<<
Techinky vkladania dizajnovych informacii do kodu, naming pattern, structural pattern (marker interface), annotations (spominaju tu constraints, a aj nejake filozofovanie), automaticky derivovane semanticke vlastnosti (nie len syntax).
Obkecavaju ako pridavali anotacie do svojho jazyka Compose*, a potom aj o vkladani anotacii.
> Co takto navrhnut riesenie interferencie aspektov prostrednictvom nav?zovania aspektov nie na base kode ale na seba navzajom?
Design information ako semanticke anotacie. -> tvrdia ze pointcut sa musi viazat na semanticke informacie
The Attrib4j [7] and Apache Common Attributes
AspectWerkz, JBoss AOP, AspectJ
>>>
<<<
utilizingDesignInformation
>>>
<<<
Nagy, I.; Bergmans, L.; Havinga, W. \& Aksit, M. (2005), 'Utilizing Design Information in Aspect-Oriented Programming', in Net.ObjectDays, NODe/GSEM, September 20-22, 2005, Erfurt, Germany, pp. 39--60
>>>
<<<
naming conventions;AOP;marker interfaces;annotations;@OP;attribute-oriented programming;theory;internal metadata;navigation;superimposition of annotations;idea;semantic annotations;special annotations;history;AOP annotations;locality;dumb;
>>>

<<<
JavaML: a markup language for Java source code
>>>
<<<
D:/attr/views/JavaML a markup language for Java source code;
>>>
<<<
Nevyhody textovej reprezentacie, ako riesenie kanonicke vyjadrenie Javy pomocou XML.
Struvny popis Javy a XML, v XML idref ako moznost vyjadrenia directed grafov, nielen stromov.
uprava Jikes frameworku ktory preklada java aj na output JavaML, sp?tny preklad je umozneny pomocou XSLT, rozne pouztia javaML - analyza kodu (pocet metod, vyber specifickych struktur v kode a pod.), jednoduchsie zmeny v kode ako pri textovom tvare (textovy editor zmeni napr kazdy vyskyt, tu si vieme vyselektovat ze iba napr nazvy metod - refactoring v nb, eclipse), Microsoft?s Intentional Programming group - mozno vyvoj XML DSL pomocou JavaML a DTD - preklad pomocou XSLT.
>>>
<<<
javaML
>>>
<<<
Badros, G. J. (2000), 'JavaML: a markup language for Java source code', in Computer Networks, vol. 33, no.1--6, pp. 159--177
>>>
<<<
program comprehension;XML;code query;views;
>>>

<<<
Reducing syntactic noise in internal domain-specific languages
>>>
<<<
D:/attr/views/Reducing syntactic noise in internal domain-specific languages;
>>>
<<<
iDSLAddon
>>>
<<<
iDSLAddon
>>>
<<<
Nosá¾, M.; Porubän, J. \& Nosá¾, M. (2012), 'Reducing syntactic noise in internal domain-specific languages', in Proceedings of CSE 2012 : International Scientific Conference on Computer Science and Engineering, October 3-5, 2012, Košice : FEI TU, 2012, pp. 111--118
>>>
<<<
new;views;annotations application;iDSLAddon;special annotations;
>>>

<<<
Xdoclet for more effective EJB development
>>>
<<<
D:/attr/XDoclet/xdoclet;
>>>
<<<
Motivacia pre xDoclet - ale vlastne pre generativne programovanie spojene s @OP

v tomto pripade ide vlastne o modelovanie modelu (pre generator) v kode

Reduce redundancies, allow ?single point of reference?
- Write less code
- Avoid boring, repetitive and error prone tasks
- Improve maintainability
Apply well-proven low-level code idioms
- Make the code cleaner
- Avoid bugs
>>>
<<<
xDoclet
>>>
<<<
ELCA -- ZH -- 2004, 'Xdoclet for more effective EJB development', Xdoclet Basic Idea and Homeinterface, Java, 2004
>>>
<<<
xDoclet;@OP;attribute-oriented programming;generative programming;special annotations;
>>>

<<<
Code Generation Framework for Grid Development
>>>
<<<
D:/attr/XDoclet/XDcolet app/Code Generation Framework for  Grid Development;
>>>
<<<
Generativny framework pre nejaky grid, ktory najprv vyuziva Velocity na vygenerovanie zdrojov ktore su anotovane XDocletom, ktore nasledne spracuje na vytvorenie finalnej applickacie.
>>>
<<<
xdocletgenFramework
>>>
<<<
Jiang, L.; Wang, R. \& Wang, H. (2006), 'Code Generation Framework for Grid Development', in The Journal of China Universities of Posts and Telecommunications, vol. 13, no. 2, June 2006, pp. 39--42
>>>
<<<
XDoclet;Java annotations;metaprogramming;annotations application;special annotations;generative programming;
>>>

<<<
Overview of Literate and Elucidative Programming
>>>
<<<
D:/attr/documentation/nosal_eluc_prog;
>>>
<<<
Moj prehlad.
>>>
<<<
nosalElucScyr
>>>
<<<
Nosá¾, M. (2012), 'Overview of Literate and Elucidative Programming', in SCYR 2012: Proceedings from conference: 12th Scientific Conference of Young Researchers, May 15th, 2012, Her¾any, Slovakia, Košice 2012
>>>
<<<
elucidative programming;documentation programming;documentation;
>>>

<<<
A Comparison of Tool Support for Textual Domain-Specific Languages
>>>
<<<
DSL/A Comparison of Tool Support for Textual Domain-Specific Languages.pdf;
>>>
<<<
Preh¾ad o jazykovych workbenchov. 
A tool that support end-programmers creating, editing, and maintaining pro-grams in a DSL is called a language workbench.
Porovnavaju 4 tooly na generovanie workbenchov:
Pouzivaju kriteria pre jazyk : vyjadrenie abstraktnej syntexe a konkretnej syntaxe
 pre transformacie: typy cielovych poloziek (generovanych artefaktov) a operacne tranformacie (kompilacia vs interpretacia, M->M, T->M)
 pre nastroj: podporu a kontrolu

openArchitectureWare, Meta Programming System, MontiCore, IDE Meta-Tooling Platform
>>>
<<<
comparisonWorkbenchesPfeiffer
>>>
<<<
Pfeiffer, M. \& Pichler, J. (2008), 'A Comparison of Tool Support for Textual Domain-Specific Languages', in Proceedings of the 8th OOPSLA Workshop on Domain-Specific Modeling, pp. 1--7
>>>
<<<
DSL;language workbench;openArchitectureWare;Meta Programming System;MontiCore;IDE Meta-Tooling Platform;external DSL;
>>>

<<<
Domain-specific languages: An Annotated Bibliography
>>>
<<<
DSL/Domain-specific languages.pdf;
>>>
<<<
Subroutine libraries -- Object-oriented frameworks -- domain-specific language
Adomain-specific language(DSL) is a programming language or executable specification language that offers, through appropriate notations and abstractions, expressive power focused on, and usually restricted to, a particular problem domain.
Domain-specific languages are usually declarative

The benefits of DSLs include:
   DSLs allow solutions to be expressed in the idiom and at the level of abstraction of the problem domain. Consequently, domain experts themselves can understand, validate, modify, and often even develop DSL programs.
   DSL programs are concise, self-documenting to a large extent, and can be reused for different purposes [50].
   DSLs enhance productivity, reliability, maintainability [24, 47], and portability [38].
   DSLs embody domain knowledge, and thus enable the conservation and reuse of this knowledge.
   DSLs allow validation and optimization at the domain level [6, 13, 55].
   DSLs improve testability following approaches such as [71]

The disadvantages of the use of a DSL are:
   The costs of designing, implementing and maintaining a DSL.
   The costs of education for DSL users.
   The limited availability of DSLs [49].
   The difficulty of finding the proper scope for a DSL.
   The difficulty of balancing between domain-specificity and general-purpose programming language constructs.
   The potential loss of efficiency when compared with hand-coded software.

Strucny popis krokov pri tvrobe DSL, v tomto kontexte sa tu spomina pojem domenoveho analytika, domenoveho inzinierstva, opätovnej pouzitelnosti, programovych rodin a softverovej produktovej linky.

An advantage of this approach is that the compiler or interpreter of the baselanguage is reused as isfor the DSL. The main limitation is in the expressiveness of the syntactic mechanisms inthe base language. In many cases, the optimal domain-specific notation has to be compromised to fit the limitations of the base language. Typical examples of this approach are [61] (a robot control language embedded in Haskell) and [44] (a PIC-like drawing language embedded in ML). The concept of domain-specific embedded languagewas coined by Hudak [40].
>>>
<<<
dslVanDeursen
>>>
<<<
van Deursen, A.; Klint, P. \& Visser, J. (2000), 'Domain-Specific Languages: An Annotated Bibliography', ACM SIGPLAN Notices, vol. 35, no. 6, pp. 26--36
>>>
<<<
DSL;DSL definition;micro languages;little languages;embedded languages;declarative languages;advantages of DSL;disadvantages of DSL;domain engineering;domain analyst;program family;software product line;internal vs external DSLs;
>>>

<<<
Notable design patterns for domain-specific languages
>>>
<<<
DSL/Notable design patterns for domain-specific languages.pdf;
>>>
<<<
Vyhody:
 Concrete expression of domain knowledge. 
 Direct involvement of the domain expert.
 Expressiveness.
 Runtime eficiency . - o tom by sa dalo polemizovat
 Modest implementation cost - o tom tiez
 Reliability.

Nevyhody:
 Tool support limitations
 Training costs 
 Design experience
 Software process integration

Vzory:
 Piggyback - vyuzitie existujuceho jazyka, ale nemusi to byt interny, moze to byt napr. preprocessing.
 Pipeline - snura DSLiek, vystup jdneho moze byt vstupom druheho, namiesto velkeho riesenia vela malych jazykov.
 Lexical processing - jednoduchy navrh jazyka umoznujuci jednoduche spracovanie napr. lexikalnou substituciou.
 Language extension - rozsirenie eistujuceho jazyka, oproti piggymu vraj piggy pouziva hostako implementacny nastroj.
 Language specialisation
 Source-to-source transformation - ak som to spravne pochopil tak pouzitie nejakych transformacnych nastrojov namiesto implementacie vlastnych procesorov.
 Data structure representation - DSL na vyjadrovanie udajovych struktur s vela udajmi.
 System front-end - DSL na konfigurovanie systemu.
>>>
<<<
designPatternsDSL
>>>
<<<
Spinellis, D. (2001), 'Notable design patterns for domain-specific languages', in J. Syst. Softw., vol. 56, no. 1, Elsevier Science Inc., pp. 91--99
>>>
<<<
DSL;DSL pattern;DSL advantages;DSL disadvantages;DSL implementation;DSL design;
>>>

<<<
Khepera: A System for Rapid Implementation of Domain Specific Languages
>>>
<<<
DSL/Khepera A System for Rapid Implementation of Domain Specific Languages.pdf;
>>>
<<<
Navrhuju nastroj Khepera an vytvaranie DSL, ide v podstate o compiler generation kit. Jednou z chyb ktoru vytykaju inym je chybajuce sledovanie bugov z domeny, ak nieco spadne tak uz je to na urovni generovaneho kodu.
Khepera podporuje pouzitie viacerych parserov, semanticke spracovanie sa deje na urovni transformacii AST a vysledny pretty printing je podporovany na kazdom AST, teda aj na AST zo vstupneho kodu, aj na prechodnych AST aj na vystupnom. Umoznuje backtrackovat preklad, teda ak najdeme chybu v generovanom kode mali by sme vediet najst co ju sposobilo vo vstupnom kode. Aj to davaju za hlavny prinos oproti vtedajsej konkurencii + podpora
>>>
<<<
khepera
>>>
<<<
Faith, R. E.; Nyland, L. S. \& Prins, J. F. (1997), 'Khepera: A System for Rapid Implementation of Domain Specific Languages', in Proceedings of the Conference on Domain-Specific Languages on Conference on Domain-Specific Languages (DSL), DSL'97, pp. 243--255
>>>
<<<
DSL;DSL workbench;Khepera;
>>>

<<<
Jargons and Infocentrism
>>>
<<<
DSL/Jargons and Infocentrism.pdf;
>>>
<<<
Zda sa ze InfoWiz je metajazyk podobny XML, v ktorom si robia model nejakej domeny (robia teda dokumenty polozene na informaciach a nie algoritmoch -- preto infocentrizmus) a tomu dorabaju algoritmy -- "program" v jargone tak moze mat viacero vystupov na zaklade jeho interpretacie. InfoWiz pritom poskytuje interpreter.
Jargony v InfoWize su stavane na kompoziciu (myslim ze by to slo spravit aj s XML). - oproti XML je vsak viac 
Minimalizuju progamovanie na pisanie vyznamu vyrazov v jargone.
Like us, they imagine a world of information modeled in a DSL with suitable abstractions, and with late binding of the semantics of the DSL to permit information reuse. -- o tom to teda je, late binding of semantics
>>>
<<<
jargons
>>>
<<<
Nakatani, L. H. \& Jones, M. A. (1997), 'Jargons and Infocentrism', in First ACM SIGPLAN Workshop on Domain-Specific Languages, ACM Press, pp. 59--74
>>>
<<<
DSL;InfoWiz;Jargon;language collaboration;language composition;infocentrism;
>>>

<<<
Evolve Frameworks into Domain-Specific Languages
>>>
<<<
DSL/Evolve Frameworks into Domain-Specific Languages.pdf;
>>>
<<<
Good names for the objects will make the control flow less important to understanding the framework [Beck].

What varies			Design Pattern
Algorithms			Strategy
Actions			Command
Response to change		Observer
Interactions between objects	Mediator
Object being created		Factory Method
Object interfaces		Adaptor

Prakticky opis cesty od zaciatku frameworku k DSL.
>>>
<<<
frameworksToDSL
>>>
<<<
Roberts, D. \& Johnson, R. (), 'Evolve Frameworks into Domain-Specific Languages'
>>>
<<<
DSL;framework;naming;new;
>>>

<<<
Building Domain-Specific Languages for Model-Driven Development
>>>
<<<
DSL/embedded/Building Domain-Specific Languages for Model-Driven Development.pdf;
>>>
<<<
v tomto kontexte je embedded DSL skor interny, pretoze stavia na jazyku ale nie je vlozeny v zmysle vlozenia kodu tkory je ptorebne parsovat, na parsovanie staci parser hostovacieho jazyka
As we’ve said, extensibility is a key char-acteristic of RubyTL. It provides extension points for adding new features to its set of core
features, thereby letting us test whether a new feature is useful for solving transformation problems. -- anotacie ako body rozsirenia syntaxe

One of these extension points lets us define new kinds of rules, extending the default rule’s behavior. We use this extension point to illustrate how we’ve applied three common techniques used in dynamic languages:
 -- metaprogramming —the ability to write a program that writes another program,
 -- introspection— the ability to obtain infor-mation about an object or class at run-time, and
 -- intercession—a program’s ability to both inspect and modify its values at runtime.

Embedding a DSL in a host language is an alternative to constructing a com-piler or interpreter.

Language designer extends host language’s constructs with domain-specific constructs instead of building a new parser [1]. -- z iDSLAddon
>>>
<<<
buildDSL4MDD
>>>
<<<
Cuadrado, J. S. \& Molina, J. G. (2007), 'Building Domain-Specific Languages for Model-Driven Development',in  IEEE Softw., vol. 24, no. 5, pp. 48--55
>>>
<<<
emedded DSL;DSL;MDD;annotations competition;metaprogramming;
>>>

<<<
cc - A Generic Framework for Domain Specific Languages
>>>
<<<
DSL/boring/cc - A Generic Framework for Domain Specific Languages.pdf;
>>>
<<<
nieco o concurrent constraint programming (CCP) a o tom ako rodina jazykov cc pre CCP umoznuje framework pre vytvaranie DSL jazykov -- ale rozumiem tomu malo
>>>
<<<
ccGenFramDSL
>>>
<<<
Fromherz, M. P. J.; Gupta, V. \& Saraswat, V. (1997), 'cc -- A Generic Framework for Domain Specific Languages', in POPL Workshop on Domain Specific Languages
>>>
<<<
DSL;
>>>

<<<
Modular Domain Specific Languages and Tools
>>>
<<<
DSL/embedded/Modular Domain Specific Languages and Tools.pdf;
>>>
<<<
A domain specific language (DSL) is a programming language tailored for a particular application domain. Characteristic of an effective DSL is the ability to develop complete application programs for a domain quickly and effectively.
In sophisticated domains, the domain engineer is the person we want to use a DSL.
1. We begin with the assumption that we really don’t want to build a new programming language from scratch. Better, let’s inherit the infrastructure of some other language -- tailoring it in special ways to the domain of interest -- thus yielding a domain-specific embedded language (DSEL).
2. Building on this base, we can then concentrate on semantic issues. Sound abstraction principles can be used at this level to build language tools that are themselves easy to understand, highly modular, and straightforward to evolve. 

makrá ako embedded DSL

emebdded dsls maju za vyhodu aj to, ze okrem samotneho DSL poskytuju aj konstrukcie z hostovacieho jazyka teda aj silu gpl
 -- taktiez aj pohodlnejsia kompozicia pri jazykoch postavenych na tom istom hostovaciom gpl

inak zda sa ze pojde skor o interny nez o embedded jazyky

inak je zaujimave uvedomit si vztah medzi DSL jazykmi a pouzivanim zmyslupnych identifikatorov pri programovani v GPL

Internal (or embedded as in [9, 10]) DSL is a morphed GPL. -- z idsladdon, pozor ale, embedded a internal nie je to iste
>>>
<<<
modularDSLandTools
>>>
<<<
Hudak, P. (1998), 'Modular Domain Specific Languages and Tools', in Proceedings of the 5th International Conference on Software Reuse, ICSR '98, IEEE Computer Society, pp. 134--
>>>
<<<
DSL;embedded DSL;DSL definition;domain engineer;domain expert;embedded DSL definition;macro;
>>>

<<<
Common Abstraction of Configuration from Multiple Sources
>>>
<<<
application/configuration/Common Abstraction of Configuration from Multiple Sources.pdf;
>>>
<<<
bte clanok v acta
>>>
<<<
actaBTE
>>>
<<<
Porubän, J. \& Nosá¾, M. (2011), 'Common Abstraction of Configuration from Multiple Sources', in Acta Electrotechnica et Informatica, vol. 11, no. 4, 2011, pp. 25--30, DOI: 10.2478/v10198-011-0038-3
>>>
<<<
annotations application;@OP vs XML;Java annotations;annotations position;locality;internal vs external;configuration;BTE;
>>>

<<<
Domain-specific languages
>>>
<<<
DSL/Domain Specific Languages - Fowler.pdf;
>>>
<<<
fowler je klasika
>>>
<<<
fowlerDSL
>>>
<<<
Fowler, M. (2010), 'Domain-specific languages', Addison-Wesley Professional, 2010
>>>
<<<
new;DSL;internal DSL;external DSL;language workbench;
>>>

<<<
Automatic generation of language-based tools using the LISA system
>>>
<<<

>>>
<<<
tools
>>>
<<<
mernikLisaTools
>>>
<<<
Henriques, P. R.; Varando Pereira, M. J.; Mernik, M.; Leniè, M.; Gray, J. G. \& Wu, H. (2005), 'Automatic generation of language-based tools using the LISA system', in IEE proc., Softw., April 2005, vol. 152, no. 2, pp. 54--69
>>>
<<<
new;DSL;LISA;
>>>

<<<
A reusable object-oriented approach to formal specifications of programming languages
>>>
<<<

>>>
<<<
LISA
>>>
<<<
mernikLisa
>>>
<<<
@article{mernikLisa,
    author = {Mernik, Marjan and Leni\v{c}, Mitja and Avdicausevic, Enis and Zumer, Viljem},
    citeulike-article-id = {3735574},
    citeulike-linkout-0 = {http://citeseer.ist.psu.edu/old/mernik00reusable.html},
    journal = {L'Object},
    keywords = {attribute\_grammars, lisa},
    pages = {273--306},
    posted-at = {2008-12-02 14:54:07},
    priority = {2},
    title = {{A Reusable Object-Oriented Approach to Formal Specifications of Programming Languages}},
    url = {http://citeseer.ist.psu.edu/old/mernik00reusable.html},
    volume = {4},
    year = {1998}
}
>>>
<<<
new;LISA;DSL;
>>>

<<<
A SOURCE CODE BASED MODEL TO GENERATE GUI
>>>
<<<
application/definicia rozhrani/A SOURCE CODE BASED MODEL TO GENERATE GUI.pdf;
>>>
<<<
Principialne so far to vyzera na nieco podobne ako som uz raz cital, chcu generovat GUI podla anotovaneho modelu, aby sa menej casu venovalo GUI a viac samotnemu aplikacnemu kodu.
// IDEA: ORM mapovanie, mapovanie medzi biznis kodom a GUi -- na podobny sposob nevieme najst nieco nove?
Odkazat Misku na toto, lebo tam maju prehod do GUI ktory im hvori aky typ vôlastnosti sa mapuje na aky typ GUI komponentov. Cize mi to prijde dost podobne, teda vidim tam suvislost.
Tie intrinsic metadata nazyvaju aj language metadata, teda nie tie custom.
Maju tam zuajimavu koncepciu "napajacieho ramca" (binding framework), ktory sa stara o vyvolavanie sparvnych udalosti a ich spracovanie pre potreby navigacie v GUI - "button was clicked" vs. "show me a representation of this book instance"
Inak vyzera to dost drsne.
BTW: dlhsia verzia toho co som tu uz mal, cize to tu je uz odpublikovane.
>>>
<<<
guiGenerationMonteiro
>>>
<<<

>>>
<<<
new;annotation definition;GUI generation;generative programming;annotations;attribute-oriented programming;idea;annotations classification;
>>>

<<<
Java in the High Performance Computing arena: Research, practice and experience
>>>
<<<
parallel/java/Java in the High Performance Computing arena Research, practice and experience.pdf;
>>>
<<<
Prehladovy clanok spolu s nejakjym porovnanim dvoch technologii implementacie message passing. V principe rozoberaju vyskum v obalsti Javy a High Performance Computing.
>>>
<<<
javaParallel
>>>
<<<
@article{javaParallel,
title = "Java in the High Performance Computing arena: Research, practice and experience ",
journal = "Science of Computer Programming ",
volume = "78",
number = "5",
pages = "425 - 444",
year = "2013",
note = "<ce:title>Special section: Principles and Practice of Programming in Java 2009/2010 &amp; Special section: Self-Organizing Coordination</ce:title> ",
issn = "0167-6423",
doi = "http://dx.doi.org/10.1016/j.scico.2011.06.002",
url = "http://www.sciencedirect.com/science/article/pii/S0167642311001420",
author = "Guillermo L. Taboada and Sabela Ramos and Roberto R. Expósito and Juan Touri?o and Ramón Doallo",
keywords = "Java",
keywords = "High Performance Computing",
keywords = "Performance evaluation",
keywords = "Multi-core architectures",
keywords = "Message-passing",
keywords = "Threads",
keywords = "Cluster",
keywords = "InfiniBand "
}
>>>
<<<
Java;parallel;high performance;message passing;shared memory;distributed programming;distributed memory;
>>>

<<<
How Persistent Memory Will Change Software Systems
>>>
<<<
memory/How Persistent Memory Will Change Software Systems.pdf;
>>>
<<<
Tak trosku vizionarsky clanok o tom ako perzistentna pamat zmeni softver.
>>>
<<<
persistentMemoryVision
>>>
<<<
@ARTICLE{persistentMemoryVision, 
author={Badam, A.}, 
journal={Computer}, 
title={How Persistent Memory Will Change Software Systems}, 
year={2013}, 
volume={46}, 
number={8}, 
pages={45-51}, 
keywords={data privacy;digital storage;security of data;storage management;persistent memory;power consumption;software system;system applications design;File systems;Hardware;Memory management;Nonvolatile memory;Random access memory;Storge systems;nonvolatile memory;persistent RAM;storage systems}, 
doi={10.1109/MC.2013.189}, 
ISSN={0018-9162},}
>>>
<<<
memory management;software systems;databases;
>>>

<<<
Skew-space garbage collection
>>>
<<<
memory/management/garbage/Skew-space garbage collection.pdf;
>>>
<<<
Vysvetlenie garbage collectorov, hovoria o pocitani objektov a o tracingu, tracingove kopirovacie poterbuju aspon polku heapu na prekopirovanie stavu (kopiruju sa len live, ale live moze byt vsetky).
Hovoria ze mozem alokovat menej ako polku lebo to vedia predikovat, vdaka comu chcu znizit pocet volani GC. Je to vsak mozne? Ak rezervujem menej miesta tak potom sa mi to miesto skor minie, cize len presuniem problem inam. Nieco asi nechapem. Dalej vsak akoby vraveli ze menej alokovaneho miesta znamena viac miesta na alokaciu objektov (ale to je zrejme myslene inak).
zrejme to funguje takto: GC alokuje miesto na skopirovanie survivorov, a caka na to kym sa zaplni nealokovane miesto. ak sa zaplni, spusti sa GC a survivori sa skopiruju do alokovaneho miesta, ale to miesto sa neoznaci ako working space, ale zarezervuje sa znova miesto na survivorov a zvysok je working space. -- ano je to tak
Par obrazkov o tom ze memory usage u programov je viac menej konstatny resp. stabilny.
>>>
<<<
skewGarbCol
>>>
<<<
@article{skewGarbCol,
 author = {Tong, Liangliang and Lau, Francis C. M.},
 title = {Skew-space garbage collection},
 journal = {Sci. Comput. Program.},
 issue_date = {May, 2013},
 volume = {78},
 number = {5},
 month = may,
 year = {2013},
 issn = {0167-6423},
 pages = {445--457},
 numpages = {13},
 url = {http://dx.doi.org/10.1016/j.scico.2011.06.003},
 doi = {10.1016/j.scico.2011.06.003},
 acmid = {2452261},
 publisher = {Elsevier North-Holland, Inc.},
 address = {Amsterdam, The Netherlands, The Netherlands},
 keywords = {Garbage collection, Mark compact, Semi space, Skew space, Space efficiency},
}
>>>
<<<
memory management;garbage collector;garbage collection;memory consumption;
>>>

<<<
Parallel execution of Java loops on Graphics Processing Units
>>>
<<<
parallel/java/Parallel execution of Java loops on Graphics Processing Units.pdf;
>>>
<<<
Principialne clanok o tom ako spravili automaticky paralelizator sluciek pre Javu. Kriticke casti paralelizuju a posielaju na GPGPU. Okrem toho poskytuju model, podla ktoreho urcuju ci sa vobec oplati posielat vypocet na GPGPU (model ktory vypocita cas na CPU a cas na GPU - je parametrizovany aby mohol fungovat na multiple platformach).
GPU implicitne a explicitne slucky, implicitne su tie ktore sa vykonaju ale nemusia byt zapisane v programe. - podmienky ako identifikovat rozne slucky
Zaujimavy pokec o tom ako Java zvlada Arrays prave kvoli zavislostami medzi iteraciami (multidimensional array je implementovany ako aray of arrays).
>>>
<<<
parallelLoopsJava
>>>
<<<
@article{parallelLoopsJava,
 author = {Leung, Alan and Lhot\'{a}k, Ondej and Lashari, Ghulam},
 title = {Parallel execution of Java loops on Graphics Processing Units},
 journal = {Sci. Comput. Program.},
 issue_date = {May, 2013},
 volume = {78},
 number = {5},
 month = may,
 year = {2013},
 issn = {0167-6423},
 pages = {458--480},
 numpages = {23},
 url = {http://dx.doi.org/10.1016/j.scico.2011.06.004},
 doi = {10.1016/j.scico.2011.06.004},
 acmid = {2452263},
 publisher = {Elsevier North-Holland, Inc.},
 address = {Amsterdam, The Netherlands, The Netherlands},
 keywords = {GPU, Java, Parallelization},
}
>>>
<<<
parallel programming, parallel computing;GPGPU;Java;loops;
>>>

<<<
When intuition and logic clash: The case of the object-oriented paradigm
>>>
<<<
oop/When intuition and logic clash The case of the object-oriented paradigm.pdf;
>>>
<<<
One reason for that is that people’s conception of reality cannot be considered separately from the objective reality. As people interact with the world, they automatically and subconsciously apply their accrued concepts and theories to the observed phenomena in order to understand them. Consequently, people’s explanatory theories do not capture the natural order of the world; rather, they are subjective to the person applying them. -- nieco o vlastnom pohlade na svet
vela dobrych citacii vyzera byt
Another aspect that may affect OO problem decomposition and the resulting class hierarchy is the designers’ knowledge about the target system. Designers familiar with the system will organize the decomposition of the new problem according to their knowledge of existing systems’ classes, thus promoting the goal of code reuse, which is one of the core principles of OO. In contrast, designers that are unfamiliar with their target OO systems might be induced by the naturalness of object-based decomposition to produce designs with unnecessary and possibly inefficient distinctions as well as erroneous inheritance structures [21].
Clanok analyzuje problemy skusenych OO programatorov.

The phenomenon illustrated above, however, seems to justify the remark made by Baragry [34], that people automatically and subconsciously apply their accrued concepts and theories to the observed phenomena in order to understand them; consequently, people’s explanatory theories do not capture the natural order of the world, rather they are subjective to the person using them.

Berge et al. [62] recommend letting students develop systems they are familiar with as their first OO development tasks. They also explain that students’ individual experiences with similar systems may confuse them when deciding on software objects and the relationships between them, due to their perceptions of these objects in the physical world.

Fleury claims that this stems from the fact that it is easier for students to read the code in a sequence following a certain scenario rather than to look for a code section located elsewhere in the program each time. The origin of this phenomenon, like other phenomena Fleury identified, is the tendency to read code line by line while trying to understand it in the context of a concrete example.

Hatton [1] noted that, other than for GUI building, reuse is not an outstanding success in OO (specifically C++), despite the fact that it is the second most common reason developers switch to that paradigm in the first place.

Dobry clanok, vysvetluje preco sa robia chyby pri OOD/A.
>>>
<<<
oopClash
>>>
<<<
@article{oopClash,
title = "When intuition and logic clash: The case of the object-oriented paradigm ",
journal = "Science of Computer Programming ",
volume = "78",
number = "9",
pages = "1407 - 1426",
year = "2013",
note = "",
issn = "0167-6423",
doi = "http://dx.doi.org/10.1016/j.scico.2012.10.006",
url = "http://www.sciencedirect.com/science/article/pii/S0167642312001918",
author = "Irit Hadar",
keywords = "Object-oriented analysis and design",
keywords = "Cognitive processes",
keywords = "Intuition",
keywords = "Qualitative research "
}
>>>
<<<
projections;OOP;object-oriented programming;object-oriented design;objecto-oriented analysis;
>>>

<<<
FeatureIDE: An extensible framework for feature-oriented software development
>>>
<<<
spl/features/FeatureIDE An extensible framework for feature-oriented software development.pdf;
>>>
<<<
Hovoria o podpore feature programming, ze featureIDE uz davno zacali ale najprv to bola len akasi fasada na nejaky toolkit, a teraz to podporuje viac veci.
Feature je vlastne nejaky aspekt systemu pozorovatelny pouzivatelom.
FeatureIDE je framework ktory ako keby zapuzdroval FOSD (feature-oriented software development). Umoznuje pracovat v IDE pocas celeho cyklu SPL. Implementovnay ako IDE na Eclipse platforme.
>>>
<<<
featureIDE
>>>
<<<
@article{featureIDE,
title = "FeatureIDE: An extensible framework for feature-oriented software development ",
journal = "Science of Computer Programming ",
volume = "",
number = "0",
pages = " - ",
year = "2012",
note = "",
issn = "0167-6423",
doi = "http://dx.doi.org/10.1016/j.scico.2012.06.002",
url = "http://www.sciencedirect.com/science/article/pii/S0167642312001128",
author = "Thomas Thüm and Christian Kästner and Fabian Benduhn and Jens Meinicke and Gunter Saake and Thomas Leich",
keywords = "Feature-oriented software development",
keywords = "Software product lines",
keywords = "Feature modeling",
keywords = "Feature-oriented programming",
keywords = "Aspect-oriented programming",
keywords = "Delta-oriented programming",
keywords = "Preprocessors",
keywords = "Tool support "
}
>>>
<<<
Feature-oriented software development;Software product lines;Feature modeling;Feature-oriented programming;Tool support;Aspect-oriented programming;Delta-oriented programming;Preprocessors;
>>>

<<<
How influential has academic and industrial research been in current software life cycles? A retrospective analysis of four mainstream activities
>>>
<<<
software engineering/lifecycle/How influential has academic and industrial research been in current software life cycles A retrospective analysis of four mainstream activities.pdf;
>>>
<<<
V podstate prehlad toho ako research ovplyvnil prax v styroch oblastiach. ma nadeifnovae aku methodu pouzil, hovori o iterativnom vyvoji, architekturo-centrickom vyvoji,
>>>
<<<
researchInfluenceLifeCycles
>>>
<<<
@article{researchInfluenceLifeCycles,
 author = {Ca\~{n}Ete-Valde\'{o}N, Jos{\'e} Miguel},
 title = {How influential has academic and industrial research been in current software life cycles? A retrospective analysis of four mainstream activities},
 journal = {Inf. Softw. Technol.},
 issue_date = {February, 2013},
 volume = {55},
 number = {2},
 month = feb,
 year = {2013},
 issn = {0950-5849},
 pages = {226--240},
 numpages = {15},
 url = {http://dx.doi.org/10.1016/j.infsof.2012.07.019},
 doi = {10.1016/j.infsof.2012.07.019},
 acmid = {2400999},
 publisher = {Butterworth-Heinemann},
 address = {Newton, MA, USA},
 keywords = {History of computing, Knowledge transfer, Practice of software development, Standardisation},
}
>>>
<<<
OOA/D;software engineering;software lifecycle;overview;iterative development;software development;
>>>

<<<
Incremental concrete syntax for embedded languages with support for separate compilation
>>>
<<<
DSL/embedded/Incremental concrete syntax for embedded languages with support for separate compilation.pdf;
>>>
<<<
Clanok, ktory Jaro recenzoval, island grammars pouzivaju na to aby pre embedded jazyk nemuseli nanovo specifikovat celu gramatiku hosta + embedded, ale dospecifikuju len embedded a u hosta definuju tzv. vodu.
Pouzivaju anotacie na definovanei konkretnej syntaxe.
>>>
<<<
incrementalConcSyntax
>>>
<<<
@article{incrementalConcSyntax,
 author = {Dinkelaker, Tom and Eichberg, Michael and Mezini, Mira},
 title = {Incremental concrete syntax for embedded languages with support for separate compilation},
 journal = {Sci. Comput. Program.},
 issue_date = {June, 2013},
 volume = {78},
 number = {6},
 month = jun,
 year = {2013},
 issn = {0167-6423},
 pages = {615--632},
 numpages = {18},
 url = {http://dx.doi.org/10.1016/j.scico.2012.12.002},
 doi = {10.1016/j.scico.2012.12.002},
 acmid = {2459794},
 publisher = {Elsevier North-Holland, Inc.},
 address = {Amsterdam, The Netherlands, The Netherlands},
 keywords = {Domain-specific languages, Generic pre-processor, Language design and implementation, Language embeddings, Program transformation},
}
>>>
<<<
DSL;domain-specific language;embedded;internal;island grammar;tools;
>>>

<<<
Modular Contracts with Procedures, Annotations, Pointcuts and Advice
>>>
<<<
theory/AOP/Modular Contracts with Procedures, Annotations, Pointcuts and Advice.pdf;
>>>
<<<
AOP pouzite na definovanie design by contract, design constraints su vlastne croscutting concern systemu.
Ukazuju priklad siestich roznych pristupov:
GOFP - good old fashioned procedures -- volania stat. metody s testom, JC.requires(cond, msg);
Enhanced-GOFP --JC.requires(new MoveByParametersCheckingTester(dx, dy, "Point.moveBy"))
Pointcuts-advice -- 
	void moveBy(int dx, int dy) {
		setX(getX() + dx);
		setY(getY() + dy);
	}
	before(int dx, int dy):
		execution(void Point.moveBy(int, int)) && args(dx, dy) {
		JC.requires(new MoveByParametersCheckingTester(dx, dy, "Point.moveBy"));
	}
Annotation-Pointcuts-Advice -- 
	@PointMoveByParametersChecking
	void moveBy(int dx, int dy) {
	...
	before(int dx, int dy):
	  execution(@PointMoveByParametersChecking * *(..))
	anotacie mozu byt vlozene cez ITD
Enhanced-Pointcuts-Advice --
	pouzivaju takz. XPI, crosscut programming interfaces, kde v specialnom aspekte nadefinuju pointcut, ktory identifikuje vsetky joinpointy pre najeky design constraint, asi daco nechapem ale nevidim vyznam toho rozdelenia, to volanie je aj tak zavisle na pointcute a pointcut je aj tak len jeden..
Enhanced-Annotation-Pointcuts-Advice -- podobne ako predchadzajuce. rozumiem ze to oddelenie moze trosku zjednodusit pracu s nimi, ale.. neviem, mam pocit ze slubovali nieco viac. Ale ze vraj im ide o modulartiu, a tie pointcuty sa zrejme daju reusovat.

v Discussion hovoria ze Tool support riesi problem toho, ze AOP rusi efekt dokumentacie (pre a post conditions su ako dokumentacia). AJDT poskytuje tie skratky.
>>>
<<<
modDesignContractAOP
>>>
<<<
@inproceedings{modDesignContractAOP,
 author = {Rebelo, Henrique and Lima, Ricardo and Leavens, Gary T.},
 title = {Modular Contracts with Procedures, Annotations, Pointcuts and Advice},
 booktitle = {Proceedings of the 2011 Brazilian Symposium on Programming Languages},
 series = {SBLP'11},
 year = 2011
}
>>>
<<<
AOP;Aspect-oriented programming;Design by Contract;Views;Projections;Tool support;XPI;
>>>

<<<
Discussion of Design Alternatives for JML Java 5 Annotations
>>>
<<<
theory/design/Discussion of Design Alternatives for JML Java 5 Annotations.pdf;
>>>
<<<
Jednoducha diskusia o troch moznostiach ako prepisat JML komentar-based annotatacie do Java anotacii. Su zhodnotene tri moznosti, bud dat jednu anotaciu a do nej text toho co bolo predtym v komentari, alebo rozstrukturalizovat cele anotacie do anotacneho jazyka, alebo tretie je ako zmiesanina oboch pristupov. Argumentuju za zmiesaninu, lebo cely prepis ma vrajnejake nevyhody (nasiel som ze readability, lebo ze sa tazsie cita ked je ten clause rozbity na parametre anotacii).
>>>
<<<
designAlternativesAnnJava5
>>>
<<<
@techreport{designAlternativesAnnJava5,
 author = {Boysen, Kristina P. and Leavens, Gary T.},
 title = {Discussion of Design Alternatives for JML Java 5 Annotations},
 institution = {Computer Science, Iowa State University},
 year = 2008,
 number = {Technical Report 08-01}
}
>>>
<<<
Design;Annotations Design;Annotations;JML;Annotations Usage;
>>>

<<<
Visualizing Software Product Line Variabilities in Source Code
>>>
<<<
views/Visualizing Software Product Line Variabilities in Source Code.pdf;
>>>
<<<
Riesia proiblem sledovania features (tracing) do kodu. Uzitocne napr. ak chceme z kodu konfiguratelneho systemu (teda zo SPL) vyextrahovat features. Pouzivaju CIDE -- Colored Integrated Development Environment.
Pri SPL je compositional vs annotative approach, bud sa system komponuje z viacerych suborov alebo sa vyradzuju podla anotacii casti ktore su naviac. Kompozicny pristup je fajn co sa tyka traceability, ale ma prblem s drobnozrnymi features. (AOP je vlastne niekde v strede).
virtual separation of concerns  -- kod je ako v annotative, ale je manazovany nastrojom.
Typicke projekcie. Projekcia aj nad filesystemom, pocmocou filtra je mozne vybrat si ktore subory sa maju zobrazit (implementujuce ktory feature). Dokonca sa zda ze robia schovavanie kodu.
Mozno by sa dala vziat literatura.
Urcite pozriet source code.
>>>
<<<
visualizingFeaturesInCode
>>>
<<<
@INPROCEEDINGS{visualizingFeaturesInCode,
    author = {Kästner, Christian and Trujillo, Salvador and Apel, Sven},
    title = {Visualizing Software Product Line Variabilities in Source Code},
    booktitle = {In Proc. SPLC Workshop on Visualization in Software Product Line Engineering (ViSPLE)},
    year = {2008}
}
>>>
<<<
SPL;software product line;software families;tool support;views;projections;CIDE;
>>>

<<<
AUTOMATICALLY CREATING GRAPHICAL USER INTERFACES USING  EXTENDED senseGUI LIBRARY
>>>
<<<
application/definicia rozhrani/AUTOMATICALLY CREATING GRAPHICAL USER INTERFACES USING  EXTENDED senseGUI LIBRARY.pdf;
>>>
<<<
Dve anotacie s kopou parametrou, amater. Vyznam svojho pristupu stavia na jednoduchosti. Amaterske pridavanie validatora, namiesto registracie triedy cez anotaciu s class, tam registruju manualne nad generovanym oknom. Nehovoriac o tom ze generuju cez reflexiu.
>>>
<<<
guiGenerationAnnotations
>>>
<<<
@inproceedings{guiGenerationAnnotations,
 author = {Trzaska, Mariusz},
 title = {Automatically Creating Graphical User Interfaces Using Extended senseGUI Library},
 booktitle = {Proceedings of the Ninth IASTED International Conference on Software Engineering and Applications},
 series = {SEA’08},
 pages = {112--117},
 year = 2008
}
>>>
<<<
annotations;generation;generative programming;GUI;user interface;annotations application;annotations design;annotation usage;
>>>

<<<
Enforcing Contracts for Aspect-oriented programs with Annotations, Pointcuts and Advice
>>>
<<<
theory/AOP/Enforcing Contracts for Aspect-oriented programs with Annotations, Pointcuts and Advice.pdf;
>>>
<<<
No ak to spravne chapem, tak oddeluju pointcut od samotnej implementacie pre a post podmienok -- je vsak stale podla mna otazka ci to ma nejaky vyznam. Ten pointcut vraj predstavuje contract medzi adviceom a triedou. Z prikladov mam pocit ze nevedia co je to design by contract (aspekt pouzivaju nie na test splnenia pre a post, ale na to aby to splnili, co je vlastne origos AOP). Teraz ked citam contributions, tak mam pocit ze chcu robit checking contractu na aspektoch, teda ako by sa posunuli inam nez v tom druhom clanku o XPI.
>>>
<<<
enforcingContractsAOPAnn
>>>
<<<
@inproceedings{enforcingContractsAOPAnn,
  author    = {Henrique Reb{\^e}lo and
               Ricardo Massa Ferreira Lima and
               Alexandre Mota and
               Cesar A. L. Oliveira and
               M{\'a}rcio Ribeiro},
  title     = {Enforcing Contracts for Aspect-oriented programs with Annotations,
               Pointcuts and Advice},
  booktitle = {SEKE},
  year      = {2012},
  pages     = {148-153},
}
>>>
<<<
AOP;aspect-oriented programming;design by contract;DbC;annotations;annotations application;XPI;XPIDR;
>>>

<<<
A Language Description is More than a Metamodel
>>>
<<<
DSL/A Language Description is More than a Metamodel.pdf;
>>>
<<<
Snazi sa opisat ako by mal vyzerat sound language description, ze vraj vela tych co riesia jazyky sa sustreduju na metamodel a zabudaju na konrektnu syntax a na semantiku.

Remembering the quote from Chomsky, immediately the flaw of this approach is clear: the concrete syntax is forced to take on the same structure as the abstract syntax. -- je toto naozaj problem?

Opisanie co s konkretnou sytanxou, aj co so semantikou.
Zaujimava definicia opisu semantiky, ako prostriedok sprostredkovania chapania vyznamu programu inej osobe. Opis co su za semantiky tie operacna atd.

definicia komponentov opisu jazyka
>>>
<<<
moreThanMetamodel
>>>
<<<
@inproceedings{moreThanMetamodel,
 author = {Kleppe, Anneke},
 title = {A Language Description is More than a Metamodel},
 booktitle = {Fourth International Workshop on Software Language Engineering},
 year = 2007
}
>>>
<<<
DSL;language engineering;language design;lagnuage development;language metamodel;concrete syntax;semantics;abstract syntax;language description;
>>>

<<<
Embedded software development with projectional language workbenches
>>>
<<<
views/Embedded software development with projectional language workbenches.pdf;
>>>
<<<
Projekcie a workbenches na projekcie, celkom dobre popisane co to je.
Because projectional  languages  by  definition  need  an  IDE  for  editing  (it  has  to  do  the projection!),  language  definition  and  extension  always  implies  IDE  definition  and extension. The  IDE  will  provide  code  completion,  error  checking  and  syntax highlighting  for  all  language  modules,  even  if  they  used  in  combinations.  Finally, because the model is stored independent of its notation, it is possible  to represent the same  model  in  different  ways  simply  by  providing  several  projections.

dost o vyzname projekcnych workbenchov, pracuju s modelom a nie s dokumentom takze su schopne zvladnut aj neplatnu vetu jazyka a pod. Hovori o tom ze funguju pekne aj pri kompozicii.

Potom zacne opisovat nejaky jazyk pre embedded systemy.
>>>
<<<
projectionalWorkbench
>>>
<<<
@inproceedings{projectionalWorkbench,
 author = {Voelter, Markus},
 title = {Embedded software development with projectional language workbenches},
 booktitle = {Proceedings of the 13th international conference on Model driven engineering languages and systems: Part II},
 series = {MODELS'10},
 year = {2010},
 isbn = {3-642-16128-6, 978-3-642-16128-5},
 location = {Oslo, Norway},
 pages = {32--46},
 numpages = {15},
 url = {http://dl.acm.org/citation.cfm?id=1929101.1929107},
 acmid = {1929107},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
 keywords = {code generation, domain-specific languages, embedded systems, language extension, projectional editing},
}
>>>
<<<
projections;views;tool support;IDE;
>>>

<<<
EXTENSIBLE HOST LANGUAGE FOR DOMAIN SPECIFIC LANGUAGES
>>>
<<<
DSL/EXTENSIBLE HOST LANGUAGE FOR DOMAIN SPECIFIC LANGUAGES.pdf;
>>>
<<<
Zacina rozoberanim kompozicie. Definuje kompoziciu jazykov na urovni meaninglful fragments. Hovori aj o kompozicii konceptov, co princiapialne hovori o tom ako sa sklada program z konceptov jazyka. Dalo by sa polemizovat o tom.
Opis EHL frameworku, argumentuje ze chce pouzit structure composition a functional composition konceptov na to aby sa mohol komponovat jazyky postavene na rovnakom host language.
>>>
<<<
sergejExtensible
>>>
<<<
@article{chodarev,
 title = {Extensible Host Language for Domain-Specific Languages},
  author = {Chodarev, Sergej and Koll\'{a}r, J\'{a}n},
  journal = {Computing and Informatics},
  year = {accepted},
}
>>>
<<<
DSL;language composition;generic language;language design;
>>>

<<<
Aspect-orientation is a rewarding investment into future code changes – As long as the aspects hardly change
>>>
<<<
theory/AOP/Aspect-orientation is a rewarding investment into future code changes – As long as the aspects hardly change.pdf;
>>>
<<<
Z toho co zatial citam tak pripravili studiu, aky vplyv ma pouzitie AOP aj pri maintenance.
Potvrdzuju to co vravime my, ze pokial su aspekty dobre, tak pomahaju, ale ak sa zmeni situacia tak ze je treba inu strukturu aspektov, tak je to zle.
Celkom fajn related work, vela o tom ako robit human centered studies, aj o tom ci su studenti vhodni ako subjekty.
Zaujimave je ze odmietli IDE aby to neovplyvnilo ich vysledky, lebo pre jeden jazyk mohla byt lepsia podpora, ktora by zvratila vysledky v prospech jedneho.
hovoria za within-subject, tzn. ze kazdy student prevedie oba experimenty (aj java aj aspectj), aby zjemnili learning effect, tak ich rozdellili na polku a jedna zacala s aspectj a druha s javou.
Ak pouzili na aspectj design ktory sa hodi na aspekty, to je fajn, lebo vlastne tie ptorebujeme podporit. Avsak akpouzili rovnaky design na OO, tak to nie je podla mna koser. Rozoberaju aj hrozby pre vlaiditu experimentu, co naznacuje ako dobre navrhnut experiment.

Zaujimave je ze spominaju ze pri zlozitejsich situaciach kedy aspkty nie su uplne zjavne sa dost komplikuje kod (v conclusion), ci to nie je proti AOP?
>>>
<<<
aopChangeStudy
>>>
<<<
@article{aopChangeStudy,
 author = {Hanenberg, Stefan and Endrikat, Stefan},
 title = {Aspect-orientation is a Rewarding Investment into Future Code Changes - As Long As the Aspects Hardly Change},
 journal = {Inf. Softw. Technol.},
 issue_date = {April, 2013},
 volume = {55},
 number = {4},
 month = apr,
 year = {2013},
 issn = {0950-5849},
 pages = {722--740},
 numpages = {19},
 url = {http://dx.doi.org/10.1016/j.infsof.2012.09.005},
 doi = {10.1016/j.infsof.2012.09.005},
 acmid = {2444429},
 publisher = {Butterworth-Heinemann},
 address = {Newton, MA, USA},
 keywords = {Aspect-oriented programming, Development time, Empirical study, Human-factors, Maintenance},
}
>>>
<<<
AOP;Aspect-oriented programming;views;projections;tool support;experiment;
>>>

<<<
Fine-Grained Annotations for Pointcuts with a Finer Granularity
>>>
<<<
na citanie/@AspectJ.pdf;
>>>
<<<
@AspectJ, anotacie na blockoch a vyrazoch umoznuju lepsie AOP
>>>
<<<
@AspectJ
>>>
<<<
@inproceedings{@AspectJ,
 author = {Cazzola, Walter and Vacchi, Edoardo},
 title = {Fine-grained Annotations for Pointcuts with a Finer Granularity},
 booktitle = {Proceedings of the 28th Annual ACM Symposium on Applied Computing},
 series = {SAC '13},
 year = {2013},
 isbn = {978-1-4503-1656-9},
 location = {Coimbra, Portugal},
 pages = {1706--1711},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2480362.2480685},
 doi = {10.1145/2480362.2480685},
 acmid = {2480685},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {AspectJ, annotations, pointcut languages},
}
>>>
<<<
AOP;aspect-oriented programming;annotations theory;annotations;Java;@AspectJ;
>>>

<<<
@Java: Bringing a richer annotation model to Java
>>>
<<<
na citanie/@Java Bringing a richer annotation model to Java.pdf;
>>>
<<<
Rozsirenie Javy o anotacie s dynamickym obsahom a viazanim sa na bloky a vyrazy
vysvetlenie preco, opisana implementacia prekladu z @Java do Java source code, potom nejaka bytecode manipulation, nasleduju 3 usecasy vysvetlujuce prinos riesenia (mozno nieco take by trebalo spravit aj do EDSLAddon) a nakoniec vyhodnotenie v zmysle rychlosti vykonavania @Java oproti Java

The ability to annotate code and, in general, the capability to attach arbitrary meta-data to portions of a program are features that have become more and more common in programming languages. Annotations in Java make it possible to attach custom, structured meta-data to declarations of classes, fields and methods. However, the mechanism has some limits: annotations can only decorate declarations and their instantiation can only be resolved statically. With this work, we propose an extension to Java (named @Java) with a richer annotation model, supporting code block and expression annotations, as well as dynamically evaluated members. In other words, in our model, the granularity of annotations extends to the statement and expression level and annotations may hold the result of runtime-evaluated expressions. Our extension to the Java annotation model is twofold: (i) we introduced block and expression annotations and (ii) we allow every annotation to hold dynamically evaluated values. Our implementation also provides an extended reflection \{API\} to support inspection and retrieval of our enhanced annotations.
>>>
<<<
@JavaJournal
>>>
<<<
@article{@JavaJournal,
title = "@Java: Bringing a richer annotation model to Java ",
journal = "Computer Languages, Systems & Structures ",
volume = "40",
number = "1",
pages = "2--18",
year = "2014",
note = "Special issue on the Programming Languages track at the 28th \{ACM\} Symposium on Applied Computing ",
issn = "1477-8424",
doi = "http://dx.doi.org/10.1016/j.cl.2014.02.002",
url = "http://www.sciencedirect.com/science/article/pii/S1477842414000037",
author = "Walter Cazzola and Edoardo Vacchi",
keywords = "Java",
keywords = "Meta-data",
keywords = "Annotations",
keywords = "Reflection ",
}
>>>
<<<
Java;@Java;annotations;annotations theory;fine-grained annotations;statements annotations;dynamic annotations;
>>>

<<<
Freely Annotating C#
>>>
<<<
na citanie/[a]C#.pdf;
>>>
<<<
To iste co @Java, akurat jednoduchsie a bez dynamickeho obsahu anotacii..
>>>
<<<
attCSharp
>>>
<<<
@article{attCSharp,
author="Cazzola, W., Cisternino, A., Colombo, D.",
title="Freely Annotating C\#",
journal="Journal of Object Technology",
year="2005",
volume="4",
number="10",
pages="31--48",
}
>>>
<<<
@Java;C#;annotations;annotations theory;dynamic annotations;
>>>

<<<
CoMA: Conformance Monitoring of Java programs by Abstract State Machines
>>>
<<<
na citanie/CoMA Conformance Monitoring of Java programs by Abstract State Machines.pdf;
>>>
<<<
Zobrazenie Java kodu pomocou anotacii do abstraktnych stavovych strojov, vhodne na annotation-based language referencing
>>>
<<<
coma
>>>
<<<
@incollection{coma,
year={2012},
isbn={978-3-642-29859-2},
booktitle={Runtime Verification},
volume={7186},
series={Lecture Notes in Computer Science},
editor={Khurshid, Sarfraz and Sen, Koushik},
doi={10.1007/978-3-642-29860-8_17},
title={CoMA: Conformance Monitoring of Java Programs by Abstract State Machines},
url={http://dx.doi.org/10.1007/978-3-642-29860-8_17},
publisher={Springer Berlin Heidelberg},
author={Arcaini, Paolo and Gargantini, Angelo and Riccobene, Elvinia},
pages={223--238},
language={English}
}
>>>
<<<
annotation-based language referencing;annotations application;mapping;
>>>

<<<
Detecting Modularity "Smells" in Dependencies Injected with Java Annotations
>>>
<<<
na citanie/Detecting Modularity “Smells” in Dependencies Injected with Java Annotations.pdf;
>>>
<<<
Dependency injection is a recent programming mechanism reducing dependencies among components by dele-gating them to an external entity, called a dependency injection framework. An increasingly popular approach to dependency injection implementation relies upon using Java annotations, a special form of syntactic metadata provided by the dependency injection frameworks. However, uncontrolled use of annota-tions may lead to potential violations of well-known modularity principles.

In this paper we catalogue “bad smells”, i.e., modularity-violating annotations defined by the developer or originating from the popular dependency injection frameworks. For each violation we discuss potential implications and propose means of resolving it. By detecting modularity bad smells in Java annotations our approach closes the gap between the state-of-the-art programming practice and currently available analysis techniques.

Rozoberaju DI a jej vplyv na modularituy, a potom deteguju bad smells v pouziti anotacii pri DI
>>>
<<<
modularitySmellsWithAnnotations
>>>
<<<
@INPROCEEDINGS{modularitySmellsWithAnnotations, 
author={Roubtsov, S. and Serebrenik, A. and van den Brand, M.}, 
booktitle={14th European Conference on Software Maintenance and Reengineering (CSMR), 2010}, 
title={Detecting Modularity "Smells" in Dependencies Injected with Java Annotations}, 
year={2010}, 
month={March}, 
pages={244--247}, 
keywords={Java;meta data;program testing;Java annotations;bad smells;dependency injection;programming mechanism;syntactic metadata;Databases;Java;Maintenance engineering;Servers;Software design;Sun;Java annotations;coding smells;configuration;dependency injection;modularity}, 
doi={10.1109/CSMR.2010.45}, 
ISSN={1534-5351},}
>>>
<<<
DI;Dependency Injection;annotations theory;annotations application;
>>>

<<<
Documenting Java Database Access with Type Annotations
>>>
<<<
na citanie/Documenting Java Database Access with Type Annotations.pdf;
>>>
<<<
Enterprise applications typically include a relational database layer. Unfortunately, the current generation of IDE’s (Integrated Development Environments) do not adequately capture the interaction between the database management system and other layers of the application. For example, current Java IDE's do not evaluate the relationship of classes with the database, or how a particular java method interacts with database tables and columns. We report here our recent progress in extending an Eclipse plug- in to use programmer supplied documentation of database access in the form of type annotations for providing a visual map of interactions between Java code and relational databases. A primary motivation is to facilitate code maintenance in the face of database modifications.

Vyzera ze rozoberaju ze staticka analyza kodu nie je nikdy dokonala a neodhali vsetky prepojenia databazy s kodom ( o co tazsie je teda vycitat intent z kodu). Pretpo navrhuju framework s anotaciami, ktory umoznuje explicitne naviazat databazu s kodom.
>>>
<<<
databaseTypeAnnotations
>>>
<<<
@inproceedings{databaseTypeAnnotations,
author = {Bergstein, Paul L.},
title = {Documenting Java Database Access with Type Annotations},
booktitle = {Proceedings of the 2012 International Conference on Software Engineering Research and Practice},
series = {SERP '12},
pages={459--465},
year = {2012},
publisher = {CSREA Press},
}
>>>
<<<
Java annotations;annotations application;mapping;database;explicit code concern;explicit code intent;projections;
>>>

<<<
Investigating the Limitations of Java Annotations for Input Validation
>>>
<<<
na citanie/Investigating the Limitations of Java Annotations for Input Validation.pdf;
>>>
<<<
Recently Java annotations have received a lot of attention as a possible way to simplify the usage of various frameworks, ranging from persistence and verification to security. In this paper we discuss our experiences in implementing an annotation framework for input validation purposes. We investigate the advantages and more importantly their limitations in the design of validation tests. We conclude that annotations are a good choice for specifying common validation tests. However, the limitations of annotations have an impact on creating and using generic tests and tests involving multiple properties.

Pomorne slabe citacie, ale zasa vyzera to pragmaticky vedecke.. jednak pragmaticky problem, validacia objektov pomocou anotacii, ale nie len pisuju ako to spravili, ale analyzuju moznosti anotacii v danej oblasti, vyhody, limity, a pod.

torsku mam zmatok z tych cross annotations ktore spajaju vlastne dve anotacie do spolocnej validacie

je to tiez tak trochu tech. report, lebo viac menej hovoria ako to spravili, ale kusa aj argumentuju a vysvetluju..
pekny framework na kompoziciu validacnych anotacii tym, ze sa pouziju na metananotovanie novej kompozitnej anotacie napr:
@Length(15, 20)
@Unique
public @interface Name {
}
takto vlastne  Length a Unique sa skomponuje na @Name
>>>
<<<
annotationsInputValidation
>>>
<<<
@INPROCEEDINGS{annotationsInputValidation, 
author={Mancini, F. and Hovland, D. and Mughal, K.A.}, 
booktitle={Proceedings of International Conference on Availability, Reliability, and Security, 2010}, 
title={Investigating the Limitations of Java Annotations for Input Validation}, 
series={ARES '10},
year={2010}, 
month={Feb}, 
pages={513--518}, 
keywords={Java;program verification;Java annotations;input validation;security verification;validation tests;Availability;Informatics;Java;Reflection;Runtime;Security;Testing;Usability;XML;Annotations;Input Validation;Java}, 
doi={10.1109/ARES.2010.29},}
>>>
<<<
annotations application;annotations design;annotations theory;validation;
>>>

<<<
jStar-eclipse: an IDE for Automated Verification of Java Programs
>>>
<<<
na citanie/jStar-eclipse an IDE for Automated Verification of Java Programs.pdf;
>>>
<<<
jStar is a tool for automatically verifying Java programs. It uses separation logic to support abstract reasoning about ob-ject specifications. jStar can verify a number of challenging design patterns, including Subject/Observer, Visitor, Factory and Pooling. However, to use jStar one has to dealwith a family of command-line tools that expect specifications in separate files and diagnose the errors by inspecting the text output from these tools.
In this paper we present a plug-in, called jStar-eclipse, allowing programmers to use jStar from within Eclipse IDE. Our plug-in allows writing method contracts in Java source files in form of Java annotations. It automatically translates Java annotations into jStar specifications and propagates errors reported by jStar back to Eclipse, pinpointing the errors to the locations in source files. This way the plug-in ensures an overall better user experience when working with jStar. Our end goal is to make automated verification based on separation logic accessible to a broader audience.


anotacie na prepis pred a post podmienok pre specifikaciu komponentov - pouzivaju string na vkladanie svojho jazyka
>>>
<<<
jStar
>>>
<<<

>>>
<<<
annotations application;jStar;
>>>

<<<
JUMP-From Java Annotations to UML Profiles
>>>
<<<
na citanie/JUMP—From Java Annotations to UML Profiles.pdf;
>>>
<<<
The capability of UML profiles to serve as annotation mechanism has been recognized in both industry and research. Today’s modeling tools offer profiles specific to platforms, such as Java, as they facilitate model-based engineering approaches. However, the set of available profiles is considerably smaller compared to the number of existing Java libraries using annotations. This is because an effective mapping between Java and UML to generate profiles from annotation-based libraries is missing. In this paper, we present JUMP to overcome this limitation, thereby continuing existing mapping efforts by emphasiz-ing on annotations and profiles. We demonstrate the practical value of JUMP by contributing profiles that facilitate reverse-engineering and forward-engineering scenarios for the Java platform. The evaluation of JUMP shows that profiles can be automatically generated from Java libraries exhibiting equal or even improved
quality compared to profiles currently used in practice.

Oproti Cepovi mam taky pocit ze je to o dost viac prakticke, Cepa skor len polemizoval, oni to spravili na profily a stereotypy

celkom pekne opisane vyhodnotenie, daju si research question a snazia sa ju nejako vyhodnotit, v ich pripade naprv riesili ake su metody zorabzena Java anotacii do UML a ake su ich implikacie, a potom riesili ze akej kvality su ich generovane profily v porovnani s pouzivanymi
priporovnani argumentuju ze ich profily su lepsie lebo maju viac detailov z anotovaneho kodu, ale nie je model prave abstrahovany?
>>>
<<<
jump
>>>
<<<
@incollection{jump,
year={2014},
isbn={978-3-319-11652-5},
booktitle={Model-Driven Engineering Languages and Systems},
volume={8767},
series={Lecture Notes in Computer Science},
editor={Dingel, Juergen and Schulte, Wolfram and Ramos, Isidro and Abrah?o, Silvia and Insfran, Emilio},
doi={10.1007/978-3-319-11653-2_34},
title={JUMP—From Java Annotations to UML Profiles},
url={http://dx.doi.org/10.1007/978-3-319-11653-2_34},
publisher={Springer International Publishing},
keywords={Java Annotations; UML Profiles; Model-Based Engineering; Forward Engineering; Reverse Engineering},
author={Bergmayr, Alexander and Grossniklaus, Michael and Wimmer, Manuel and Kappel, Gerti},
pages={552--568},
language={English}
}
>>>
<<<
annotations theory;UML;plugin;Java;MDSD;
>>>

<<<
Reified Type Parameters Using Java Annotations
>>>
<<<
na citanie/Reified Type Parameters Using Java Annotations.pdf;
>>>
<<<
Java generics are compiled by-erasure: all clients reuse the same bytecode, with uses of the unknown type erased. C++ templates are compiled by-expansion: each type-instantiation of a template produces a different code definition. The two approaches offer tradeoffs on multiple axes. We propose an extension of Java generics that allows by-expansion translation relative to selected type parameters only. This language design allows sophisticated users to get the best of both worlds at a fine granularity. Furthermore, our proposal is based on Java 8 Type Annotations (JSR 308) and the Checker Framework as an abstraction layer for controlling compilation without changes to the internals of a Java compiler.

RObia vlastne to ze typ sa dokaze selektivne ponechat pri generike
>>>
<<<
reifiedTypeParameters
>>>
<<<
@article{reifiedTypeParameters,
 author = {Gerakios, Prodromos and Biboudis, Aggelos and Smaragdakis, Yannis},
 title = {Reified Type Parameters Using Java Annotations},
 journal = {SIGPLAN Not.},
 issue_date = {March 2014},
 volume = {49},
 number = {3},
 month = oct,
 year = {2013},
 issn = {0362-1340},
 pages = {61--64},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/2637365.2517223},
 doi = {10.1145/2637365.2517223},
 acmid = {2517223},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {mixins, pluggable types, reification, type annotation},
}
>>>
<<<
annotations application;Java annotations;Type annotations;Checker framework;Java generics;
>>>

<<<
Programming with Ghosts
>>>
<<<
views/programming with ghosts.pdf;
>>>
<<<
Best practices in programming typically imply incremental coding with classes and interfaces that are either not yet defined or only partially defined. Yet integrated development environments (IDEs) don't support incremental coding well, and recent enhancements and third-party plug-ins fail to provide a seamless experience. We propose to reify undefined entities as ghosts, properly supported by the IDE. A Ghost View provides an integrated, modular view of each ghost, reflecting the current set of assumptions about a given undefined entity. This view is built unobtrusively and on the fly, without interrupting the programming workflow, and it supports program understanding tasks such as navigating from ghosts to the places where they're used. Ghosts and their usages are type-checked automatically as soon as they're defined. Busting a ghost generates a complete skeleton, in the background. Ghosts are a simple and useful metaphor to better support incremental development.
>>>
<<<
ghosts
>>>
<<<
@ARTICLE{ghosts, 
author={Callau, O. and Tanter, E.}, 
journal={Software, IEEE}, 
title={Programming with Ghosts}, 
year={2013}, 
month={Jan}, 
volume={30}, 
number={1}, 
pages={74--80}, 
keywords={data flow analysis;software tools;Ghost View;IDE;incremental coding;integrated development environments;program understanding tasks;programming practices;programming workflow;third-party plug-ins;Context awareness;Java;Programming;Search engines;Software development;User interfaces;Visualization;Context awareness;IDEs;Java;Programming;Search engines;Software development;User interfaces;Visualization;ghosts;integrated development environments;programming environments;programming tools}, 
doi={10.1109/MS.2012.49}, 
ISSN={0740-7459},}
>>>
<<<
projections;views;programming;ghosts;
>>>

<<<
Declarative Specification of Template-based Textual Editors
>>>
<<<
seminars/specification-of-template-based-editors.pdf;
>>>
<<<
Syntax discoverability has been a crucial advantage of structure editors for new users of a language. Despite this advantage, structure editors have not been widely adopted. Based on immediate parsing and analyses, modern textual code editors are also increasingly syntax-aware: structure and textual editors are converging into a new editing paradigm that combines text and templates. Current text-based language workbenches require redundant specification of the ingredients for a template-based editor, which is detrimental to the quality of syntactic completion, as consistency and completeness of the definition cannot be guaranteed.

In this paper we describe the design and implementation of a specification language for syntax definition based on templates. It unifies the specification of parsers, unparsers and template-based editors. We evaluate the template language by application to two domain-specific languages used for tax benefits and mobile applications.
>>>
<<<
templateBasedEditors
>>>
<<<
@inproceedings{templateBasedEditors,
 author = {Vollebregt, Tobi and Kats, Lennart C. L. and Visser, Eelco},
 title = {Declarative Specification of Template-based Textual Editors},
 booktitle = {Proceedings of the Twelfth Workshop on Language Descriptions, Tools, and Applications},
 series = {LDTA '12},
 year = {2012},
 isbn = {978-1-4503-1536-4},
 location = {Tallinn, Estonia},
 pages = {8:1--8:7},
 articleno = {8},
 numpages = {7},
 url = {http://doi.acm.org/10.1145/2427048.2427056},
 doi = {10.1145/2427048.2427056},
 acmid = {2427056},
 publisher = {ACM},
 address = {New York, NY, USA},
}
>>>
<<<
views;projections;editors;language definition;DSL;IDE;
>>>

<<<
Toward an engineering discipline for grammarware
>>>
<<<
seminars/toward_an_engineering_discipline_for_grammarware.pdf;seminars/toward-an-engineering-discipline-for-grammarware.pdf;
>>>
<<<
Grammarware comprises grammars and all grammar-dependent software. The term grammar is meant here in the sense of all established grammar formalisms and grammar notations including context-free grammars, class dictionaries, and XML schemas as well as some forms of tree and graph grammars. The term grammar-dependent software refers to all software that involves grammar knowledge in an essential manner. Archetypal examples of grammar-dependent software are parsers, program converters, and XML document processors. Despite the pervasive role of grammars in software systems, the engineering aspects of grammarware are insufficiently understood. We lay out an agenda that is meant to promote research on increasing the productivity of grammarware development and on improving the quality of grammarware. To this end, we identify the problems with the current grammarware practices, the barriers that currently hamper research, and the promises of an engineering discipline for grammarware, its principles, and the research challenges that have to be addressed.

vsetko je gramatika
“Grammarware comprises grammars and all grammar-dependent software”
“Grammar is structural description in software system”
“Grammar-dependent software refers to all software that involves grammar knowledge in an essential manner”
“Grammarware is a discipline for uniformly approaching analysis and manipulation of structured de?nitions”

“Metamodel includes a grammar, that is, the structural description of a modeling language”
“Model is not necessarily a grammar, since it can describe aspects other then structure”
“Grammar is certainly a model, namely a model of structures”
“Some grammars are metamodels, namely those that describe language constructs for modeling”

reasearch challenges

vid prezentacia
>>>
<<<
grammarware
>>>
<<<
@article{grammarware,
 author = {Klint, Paul and L\"{a}mmel, Ralf and Verhoef, Chris},
 title = {Toward an Engineering Discipline for Grammarware},
 journal = {ACM Trans. Softw. Eng. Methodol.},
 issue_date = {July 2005},
 volume = {14},
 number = {3},
 month = jul,
 year = {2005},
 issn = {1049-331X},
 pages = {331--380},
 numpages = {50},
 url = {http://doi.acm.org/10.1145/1072997.1073000},
 doi = {10.1145/1072997.1073000},
 acmid = {1073000},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Grammarware, automated software engineering, best practices, generic language technology, grammar-dependent software, grammars, language processing, metamodeling, model-driven development, parsers, software evolution, software transformation},
}
>>>
<<<
grammarware;grammar;metamodel;DSL;language;
>>>

<<<
Micropatterns in Grammars
>>>
<<<
seminars/micropatterns-prez.pdf;seminars/micropatterns.pdf;
>>>
<<<
Micropatterns and nanopatterns have been previously demonstrated to be useful techniques for object-oriented program comprehension. In this paper, we use a similar approach for identifying structurally similar fragments in grammars in a broad sense (contracts for commitment to structure), in particular parser specifications, metamodels and data models. Grammatical micropatterns bridge the gap between grammar metrics, which are easy to implement but hard to assign meaning to, and language design guidelines, which are inherently meaningful as
stemming from current software language engineering practice but considerably harder to formalise.

viac v prezentacii
je to studia kde analyzoval nejake gramaticke mikro vzory na nejakom korpuse gramatik
>>>
<<<
micropatternsGrammar
>>>
<<<
@incollection{micropatternsGrammar,
year={2013},
isbn={978-3-319-02653-4},
booktitle={Software Language Engineering},
volume={8225},
series={Lecture Notes in Computer Science},
editor={Erwig, Martin and Paige, RichardF. and Van Wyk, Eric},
doi={10.1007/978-3-319-02654-1_7},
title={Micropatterns in Grammars},
url={http://dx.doi.org/10.1007/978-3-319-02654-1_7},
publisher={Springer International Publishing},
author={Zaytsev, Vadim},
pages={117--136},
language={English}
}
>>>
<<<
grammar;patterns;language design;study;
>>>

<<<
Implementing Feature Variability for Models and Code with Projectional Language Workbenches
>>>
<<<
seminars/Implementing Feature Variabilityfor Models and Code with Projectional Language Workbenches.pdf;seminars/feature_variability_with_language_workbenches.pdf;
>>>
<<<
Product line engineering deals with managing and implementing the variability among a set of related products. We distinguish between two kinds of variability: configuration and customization. Customization variability can be described using programming language code or creative construction DSLs, whereas configuration variability is described using configuration based approaches, such as feature models. Many product lines have both kinds of variability, and they need to be integrated efficiently. This paper describes an approach for product line engineering using projectional language workbenches. These represent code and models with the same fundamental technology, enabling the mixing of models and code. They make the tight integration between several domain-specific languages possible and simple. Since they can store arbitrary information in models, it is possible to overlay configuration variability over customization variability (i.e. apply feature model-based configuration to code and models). Because of the projectional approach to editing, programs can be shown with or without the dependencies on feature models, they can even be rendered (and edited) for a specific variant. This approach leads to highly integrated and productive tools for product line development. The paper explains the approach, outlines the implementation of a prototype tool based on Jetbrains MPS and illustrates the benefits using a small product line for embedded systems.

pre viac vid prezentaicu
>>>
<<<
featureVariabilityProjectional
>>>
<<<
@inproceedings{featureVariabilityProjectional,
 author = {Voelter, Markus},
 title = {Implementing Feature Variability for Models and Code with Projectional Language Workbenches},
 booktitle = {Proceedings of the 2Nd International Workshop on Feature-Oriented Software Development},
 series = {FOSD '10},
 year = {2010},
 isbn = {978-1-4503-0208-1},
 location = {Eindhoven, The Netherlands},
 pages = {41--48},
 numpages = {8},
 url = {http://doi.acm.org/10.1145/1868688.1868695},
 doi = {10.1145/1868688.1868695},
 acmid = {1868695},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {domain-specific languages, feature modeling, language composition, product line engineering},
}
>>>
<<<
views;projections;editors;feature modeling;IDE;MPS;language composition;annotations;
>>>

<<<
The design and implementation of Object Grammars
>>>
<<<
seminars/ensogrammars-scp.pdf;seminars/ensogrammars-scp-prez.pdf;
>>>
<<<
An Object Grammar is a variation on traditional BNF grammars, where the notation is extended to support declarative bidirectional mappings between text and object graphs. The two directions for interpreting Object Grammars are parsing and formatting. Parsing transforms text into an object graph by recognizing syntactic features and creating the corresponding object structure. In the reverse direction, formatting recognizes object graph features and generates an appropriate textual presentation. The key to Object Grammars is the expressive power of the mapping, which decouples the syntactic structure from the graph structure. To handle graphs, Object Grammars support declarative annotations for resolving textual names that refer to arbitrary objects in the graph structure. Predicates on the semantic structure provide additional control over the mapping. Furthermore, Object Grammars are compositional so that languages may be defined in a modular fashion. We have implemented our approach to Object Grammars as one of the foundations of the Ens? system and illustrate the utility of our approach by showing how it enables definition and composition of domain-specific languages (DSLs).

vid prezentaciu
>>>
<<<
objectGrammars
>>>
<<<
@article{objectGrammars,
title = "The design and implementation of Object Grammars ",
journal = "Science of Computer Programming ",
volume = "96",
number = "4",
pages = "460--487",
year = "2014",
note = "Selected Papers from the Fifth International Conference on Software Language Engineering (SLE 2012) ",
issn = "0167-6423",
doi = "http://dx.doi.org/10.1016/j.scico.2014.02.023",
url = "http://www.sciencedirect.com/science/article/pii/S0167642314000902",
author = "Tijs van der Storm and William R. Cook and Alex Loh",
keywords = "Domain-specific languages",
keywords = "Model-driven development",
keywords = "Language composition",
keywords = "Syntax definition ",
}
>>>
<<<
language design;parsers;enso;language composition;DSL;grammars;metamodel;
>>>

<<<
A survey of literature on the teaching of introductory programming
>>>
<<<
seminars/survey-teaching-prez-ema.pdf;seminars/survey-teaching.pdf;
>>>
<<<
Three decades of active research on the teaching of introductory programming has had limited effect on classroom practice. Although relevant research exists across several disciplines including education and cognitive science, disciplinary differences have made this material inaccessible to many computing educators. Furthermore, computer science instructors have not had access to a comprehensive survey of research in this area. This paper collects and classifies this literature, identifies important work and mediates it to computing educators and professional bodies.

We identify research that gives well-supported advice to computing academics teaching introductory programming. Limitations and areas of incomplete coverage of existing research efforts are also identified. The analysis applies publication and research quality metrics developed by a previous ITiCSE working group [74].

viac v prezentacii

prilozene su aj anotovane odporucane publikacie
>>>
<<<
surveyTeaching
>>>
<<<
@article{surveyTeaching,
 author = {Pears, Arnold and Seidman, Stephen and Malmi, Lauri and Mannila, Linda and Adams, Elizabeth and Bennedsen, Jens and Devlin, Marie and Paterson, James},
 title = {A Survey of Literature on the Teaching of Introductory Programming},
 journal = {SIGCSE Bull.},
 issue_date = {December 2007},
 volume = {39},
 number = {4},
 month = dec,
 year = {2007},
 issn = {0097-8418},
 pages = {204--223},
 numpages = {20},
 url = {http://doi.acm.org/10.1145/1345375.1345441},
 doi = {10.1145/1345375.1345441},
 acmid = {1345441},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {bibliography, computing education research, introductory programming, literature survey, teaching},
}
>>>
<<<
teaching;introductory programming;language choice;survey;
>>>

<<<
Towards User-Friendly Projectional Editors
>>>
<<<
seminars/TowardsUsableProjEditors.pdf;seminars/sle2014.pdf;
>>>
<<<
str.54 

Prezentacia
>>>
<<<
userFriendlyProjEd
>>>
<<<
@incollection{userFriendlyProjEd,
year={2014},
isbn={978-3-319-11244-2},
booktitle={Software Language Engineering},
volume={8706},
series={Lecture Notes in Computer Science},
editor={Combemale, Benoît and Pearce, DavidJ. and Barais, Olivier and Vinju, JurgenJ.},
doi={10.1007/978-3-319-11245-9_3},
title={Towards User-Friendly Projectional Editors},
url={http://dx.doi.org/10.1007/978-3-319-11245-9_3},
publisher={Springer International Publishing},
author={Voelter, Markus and Siegmund, Janet and Berger, Thorsten and Kolb, Bernd},
pages={41--61},
language={English}
}
>>>
<<<
views;projections;projectional editors;study;IDE;editor;
>>>

<<<
Eco: A Language Composition Editor
>>>
<<<
seminars/eco.pdf;seminars/sle2014.pdf;
>>>
<<<
str. 95

prezentacia

language boxes
>>>
<<<
ecoCompositionEditor
>>>
<<<
@incollection{ecoCompositionEditor,
year={2014},
isbn={978-3-319-11244-2},
booktitle={Software Language Engineering},
volume={8706},
series={Lecture Notes in Computer Science},
editor={Combemale, Benoit and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
doi={10.1007/978-3-319-11245-9_5},
title={Eco: A Language Composition Editor},
url={http://dx.doi.org/10.1007/978-3-319-11245-9_5},
publisher={Springer International Publishing},
author={Diekmann, Lukas and Tratt, Laurence},
pages={82--101},
language={English}
}
>>>
<<<
language composition;SDE;projectional editor;editor;IDE;language box;views;
>>>

<<<
Tool support for crosscutting concerns of API documentation
>>>
<<<
na citanie/tool support for croscutting concerns of api documentation.pdf;
>>>
<<<
Writing detailed API (Application Programming Interface) documentation is a significant task for developing a good class library or framework. However, existing documentation tools such as Javadoc provide only limited support and thus the description written by programmers for API documentation often contains scattering text. Occasionally, it also contains tangling text. This paper presents that this problem is due to crosscutting concerns of API documentation. Then it proposes our new tool named Comment-Weaver, which provides several mechanisms for modularly describing API documentation of class libraries or frameworks written in Java or AspectJ. It is an extended Javadoc tool and it provides several new tags for controlling how the text manually written by the programmers is scattering and appended to other entries or how it is moved from the original entry to another entry to be tangling. Finally this paper evaluates CommentWeaver by using three class libraries and frameworks: Javassist, the Java standard library, and Eclipse. It showed that CommentWeaver resolves the problems of scattering or tangling text and it adequately reduces the amount of description written by programmers for API documentation.
>>>
<<<
crosscuttingDocumentation
>>>
<<<
@inproceedings{crosscuttingDocumentation,
 author = {Horie, Michihiro and Chiba, Shigeru},
 title = {Tool Support for Crosscutting Concerns of API Documentation},
 booktitle = {Proceedings of the 9th International Conference on Aspect-Oriented Software Development},
 series = {AOSD '10},
 year = {2010},
 isbn = {978-1-60558-958-9},
 location = {Rennes and Saint-Malo, France},
 pages = {97--108},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1739230.1739242},
 doi = {10.1145/1739230.1739242},
 acmid = {1739242},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {API documentation, aspect-oriented programming, domain-specific language},
}
>>>
<<<
API documentation;aspect-oriented programming;AOP;DSL;
>>>

<<<
Hard-to-answer questions about code
>>>
<<<
experiment/2014-11-21-hard-questions.pdf;experiment/Hard-to-answer questions about code.pdf;
>>>
<<<
Vid prezentaciu

To build new tools and programming languages that make it easier for professional software developers to create, debug, and understand code, it is helpful to better understand the questions that developers ask during coding activities. We surveyed professional software developers and asked them to list hard-to-answer questions that they had recently asked about code. 179 respondents reported 371 questions. We then clustered these questions into 21 categories and 94 distinct questions. The most frequently reported categories dealt with intent and rationale -- what does this code do, what is it intended to do, and why was it done this way? Many questions described very specific situations -- e.g., what does the code do when an error occurs, how to refactor without breaking callers, or the implications of a specific change on security. These questions revealed opportunities for both existing research tools to help developers and for developing new languages and tools that make answering these questions easier.

Are there any common hard-to-answer questions worrying code developers, which answering is not (sufficiently) supported by a tool?

Silne hovoria o tom ze vela sa ludia pytaju na intent kodu
>>>
<<<
hardToAnswer
>>>
<<<
@inproceedings{hardToAnswer,
 author = {LaToza, Thomas D. and Myers, Brad A.},
 title = {Hard-to-answer Questions About Code},
 booktitle = {Evaluation and Usability of Programming Languages and Tools},
 series = {PLATEAU '10},
 year = {2010},
 isbn = {978-1-4503-0547-1},
 location = {Reno, Nevada},
 pages = {8:1--8:6},
 articleno = {8},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/1937117.1937125},
 doi = {10.1145/1937117.1937125},
 acmid = {1937125},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {developer questions, program comprehension},
}
>>>
<<<
study;experimentation;intent;concern;program comprehension;
>>>

<<<
Developers Ask Reachability Questions
>>>
<<<
experiment/Developers Ask Reachability Questions (2010).pdf;
>>>
<<<
A reachability question is a search across feasible paths through a program for target statements matching search criteria. In three separate studies, we found that reachability questions are common and often time consuming to answer. In the first study, we observed 13 developers in the lab and found that half of the bugs developers inserted were associated with reachability questions. In the second study, 460 professional software developers reported asking questions that may be answered using reachability questions more than 9 times a day, and 82% rated one or more as at least somewhat hard to answer. In the third study, we observed 17 developers in the field and found that 9 of the 10 longest activities were associated with reachability questions. These findings suggest that answering reachability questions is an important source of difficulty understanding large, complex codebases.

observation ako metoda experimentu
mentalny model

Developers spent a majority of their time understanding code by debugging (33%) or proposing changes and investigating their implications (28%).

One field study participant spent several minutes investigating code he had written himself a little over a year earlier because he was not certain of several important details.
>>>
<<<
reachabilityQuestions
>>>
<<<
@inproceedings{reachabilityQuestions,
 author = {LaToza, Thomas D. and Myers, Brad A.},
 title = {Developers Ask Reachability Questions},
 booktitle = {Proceedings of the 32Nd ACM/IEEE International Conference on Software Engineering - Volume 1},
 series = {ICSE '10},
 year = {2010},
 isbn = {978-1-60558-719-6},
 location = {Cape Town, South Africa},
 pages = {185--194},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1806799.1806829},
 doi = {10.1145/1806799.1806829},
 acmid = {1806829},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {code navigation, developer questions, empirical study, program comprehension, software maintenance},
}
>>>
<<<
code navigation;developer questions;empirical study;program comprehension;software maintenance;projections;intents;concerns;mental model;
>>>

<<<
Designing Useful Tools for Developers
>>>
<<<
experiment/Designing useful tools for developers.pdf;
>>>
<<<
Designing useful tools for developers requires identifying and understanding an important problem developers face and designing a solution that addresses this problem. This paper describes a design process that uses data to understand problems, design solutions, and evaluate solutions' usefulness.

Claims about a tool’s usefulness are falsifiable statements about the real world and thus scientific.

Motivating examples hypothesize a mechanism by which a tool helps, but do not provide evidence of its existence.

For example, developers may not notice how much time they spend scrolling to revisit code [20]

u mna je vlastne otazka (problem): ktory kod naplna tento zamer?

ako casto sa ludia pytaju takuto otazku? - to uz naznacil ich clanok o reachability
>>>
<<<
usefulToolsForDevelopers
>>>
<<<
@inproceedings{usefulToolsForDevelopers,
 author = {LaToza, Thomas D. and Myers, Brad A.},
 title = {Designing Useful Tools for Developers},
 booktitle = {Proceedings of the 3rd ACM SIGPLAN Workshop on Evaluation and Usability of Programming Languages and Tools},
 series = {PLATEAU '11},
 year = {2011},
 isbn = {978-1-4503-1024-6},
 location = {Portland, Oregon, USA},
 pages = {45--50},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2089155.2089166},
 doi = {10.1145/2089155.2089166},
 acmid = {2089166},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {design process, empirical software engineering, program comprehension},
}
>>>
<<<
design process;empirical software engineering;program comprehension;study;projections;editor;
>>>

<<<
Quality in use of domain-specific languages: a case study
>>>
<<<
seminars/quality-in-use-of-domain-specific-languages-a-case-study.pdf;
>>>
<<<
seminar

Domain-Specific Languages (DSLs) are claimed to increment productivity, while reducing the required maintenance and programming expertise. In this context, DSLs usability is a key factor for its successful adoption.

In this paper, we propose a systematic approach based on User Interfaces Experimental validation techniques to assess the impact of the introduction of DSLs on the productivity of domain experts. To illustrate this evaluation approach we present a case study of a DSL for High Energy Physics (HEP).

The DSL on this case study, called Pheasant (PHysicist's EAsy Analysis Tool), is assessed in contrast with a pre-existing baseline, using General Purpose Languages (GPLs) such as C++. The comparison combines quantitative and qualitative data, collected with users from a real-world setting. Our assessment includes Physicists with programming experience with two profiles; ones with no experience with the previous framework used in the project and other experienced.

This work's contribution highlights the problem of the absence of systematic approaches for experimental validation of DSLs. It also illustrates how an experimental approach can be used in the context of a DSL evaluation during the Software Languages Engineering activity, with respect to its impact on effectiveness and efficiency.

porovnanie DSL a GPL
ze vraj celkom dobre spracovany experiment
>>>
<<<
qualityDSLCaseStudy
>>>
<<<
@inproceedings{qualityDSLCaseStudy,
 author = {Bari\v{s}i\'{c}, Ankica and Amaral, Vasco and Goul\~{a}o, Miguel and Barroca, Bruno},
 title = {Quality in Use of Domain-specific Languages: A Case Study},
 booktitle = {Proceedings of the 3rd ACM SIGPLAN Workshop on Evaluation and Usability of Programming Languages and Tools},
 series = {PLATEAU '11},
 year = {2011},
 isbn = {978-1-4503-1024-6},
 location = {Portland, Oregon, USA},
 pages = {65--72},
 numpages = {8},
 url = {http://doi.acm.org/10.1145/2089155.2089170},
 doi = {10.1145/2089155.2089170},
 acmid = {2089170},
 publisher = {ACM},
 address = {New York, NY, USA},
}
>>>
<<<
domain-specific languages;experimental software engineering;language evaluation;software language engineering;usability;study;
>>>

<<<
Empirical Comparison of Visual to Hybrid Formula Manipulation in Educational Programming Languages for Teenagers
>>>
<<<
seminars/empirical-comparison-of-visual-to-hybrid-formula-manipulation-in-educational-programming-languages-for-teenagers.pdf;
>>>
<<<
Visual programming environments hold great potential for end-user programming, as they, e.g., aim at diminishing the syntactical burden and enabling a focus on the semantic aspects of coding. Hence, graphical approaches have gained attention in the context of K-12 computer science education. Scratch, as being the prime example, is a visual educational language, where even formulas are composed utilizing Lego-style blocks. However, graphical creation and manipulation of complex and nested formulas can become overly cumbersome. Thus, we propose a hybrid approach employing visual creation and textual representation of formulas. In order to evaluate the method, a usability study has been conducted, comparing Scratch to our mobile programming environment, Pocket Code. The findings, while preliminary, indicate an increased efficiency and effectiveness of the hybrid approach employed in Pocket Code in contrast to a purely visual one in Scratch for teenager users.
>>>
<<<
empiricalVisualHybridFormula
>>>
<<<

>>>
<<<
study;experiment;
>>>

<<<
Tracking human-centric controlled experiments with biscuit
>>>
<<<
seminars/Tracking human-centric controlled experiments with biscuit.pdf;
>>>
<<<
Software is created by humans, for humans. For this reason, software engineering is---above all---a human activity. Acknowledging this fact, many researchers perform controlled experiments with human subjects to evaluate the performance and usability of novel approaches and software engineering tools. However, the intrinsically non-deterministic nature of humans introduces a number of threats to the validity of such experiments. One of them concerns how to record information without influencing the behavior of the subjects involved. Another one relates to providing means to assure the correctness of the gathered data, for further pristine analyses and replication.

We present Biscuit, a tool that silently records relevant pieces of information regarding an experiment performed with human subjects. We present the main features and benefits of Biscuit by showcasing a controlled experiment of Gaucho, a next generation IDE. Based on our experience, we discuss the potential of Biscuit and outline future research in this direction.
>>>
<<<
trackingBiscuit
>>>
<<<
@inproceedings{trackingBiscuit,
 author = {Olivero, Fernando and Lanza, Michele and D'ambros, Marco and Robbes, Romain},
 title = {Tracking Human-centric Controlled Experiments with Biscuit},
 booktitle = {Proceedings of the ACM 4th Annual Workshop on Evaluation and Usability of Programming Languages and Tools},
 series = {PLATEAU '12},
 year = {2012},
 isbn = {978-1-4503-1631-6},
 location = {Tucson, Arizona, USA},
 pages = {1--6},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2414721.2414723},
 doi = {10.1145/2414721.2414723},
 acmid = {2414723},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {controlled experiments, tools},
}
>>>
<<<
study;experiment;
>>>

<<<
MontiCore: Modular Development of Textual Domain Specific Languages
>>>
<<<
language/composition/monticore.pdf;
>>>
<<<
Reuse is a key technique for a more eficient development and ensures the quality of the results. In object technology explicit encapsulation, interfaces, and inheritance are well-known principles for in-dependent development that enable combination and reuse of developed artifacts. In this paper we apply modularity concepts for domain specific languages (DSLs) and discuss how they help to design new languages by extending existing ones and composing fragments to new DSLs. We use an extended grammar format with appropriate tool support that avoids redefinition of existing functionalities by introducing language inheritance and embedding as first class artifacts in a DSL definition. Language embedding and inheritance is not only assisted by the parser, but also by the editor, and algorithms based on tree traversal like context checkers, pretty printers, and code generators. We demonstrate that compositional engineering of new languages becomes a useful concept when starting to define project-individual DSLs using appropriate tool support.
>>>
<<<
montiCoreModular
>>>
<<<
@incollection{montiCoreModular,
year={2008},
isbn={978-3-540-69823-4},
booktitle={Objects, Components, Models and Patterns},
volume={11},
series={Lecture Notes in Business Information Processing},
editor={Paige, RichardF. and Meyer, Bertrand},
doi={10.1007/978-3-540-69824-1_17},
title={MontiCore: Modular Development of Textual Domain Specific Languages},
url={http://dx.doi.org/10.1007/978-3-540-69824-1_17},
publisher={Springer Berlin Heidelberg},
author={Krahn, Holger and Rumpe, Bernhard and Völkel, Steven},
pages={297--315},
}
>>>
<<<
language composition;DSL;language workbench;
>>>

<<<
Language and IDE Modularization, Extension and Composition with MPS
>>>
<<<
language/composition/Voelter-GTTSE-MPS.pdf;
>>>
<<<
Modularization and composition of languages and their IDEs is an important building block for working efficiently with domain-specific languages. Traditionally this has been a challenge because many grammar formalisms are not closed under composition, hence syntactic composition of languages can be challenging. Composing semantics can also be hard, at least in the general case. Finally, a lot of existing work does not consider IDEs for the composed languages. This paper illustrates how JetBrains MPS addresses language and IDE modularization and composition based on a projectional editor and modular type systems and transformations. The paper also classifies composition approaches according to the dependencies between the composed languages and whether syntactic composition is supported. Each of the approaches is illustrated with an extensive example implementation in MPS.
>>>
<<<
langCompositionMPS
>>>
<<<
@incollection{langCompositionMPS,
year={2013},
isbn={978-3-642-35991-0},
booktitle={Generative and Transformational Techniques in Software Engineering IV},
volume={7680},
series={Lecture Notes in Computer Science},
doi={10.1007/978-3-642-35992-7_11},
title={Language and IDE Modularization and Composition with MPS},
url={http://dx.doi.org/10.1007/978-3-642-35992-7_11},
publisher={Springer Berlin Heidelberg},
author={Voelter, Markus},
pages={383--430},
language={English}
}
>>>
<<<
language composition;MPS;IDE;editor;language design;
>>>

<<<
Language composition untangled
>>>
<<<
language/composition/untangled.pdf;
>>>
<<<
In language-oriented programming and modeling, software developers are largely concerned with the definition of domain-specific languages (DSLs) and their composition. While various implementation techniques and frameworks exist for defining DSLs, language composition has not obtained enough attention and is not well-enough understood. In particular, there is a lack of precise terminology for describing observations about language composition in theory and in existing language-development systems. To clarify the issue, we specify five forms of language composition: language extension, language restriction, language unification, self-extension, and extension composition. We illustrate this classification by various examples and apply it to discuss the performance of different language-development systems with respect to language composition. We hope that the terminology provided by our classification will enable more precise communication on language composition.
>>>
<<<
languageUntangled
>>>
<<<
@inproceedings{languageUntangled,
 author = {Erdweg, Sebastian and Giarrusso, Paolo G. and Rendel, Tillmann},
 title = {Language Composition Untangled},
 booktitle = {Proceedings of the Twelfth Workshop on Language Descriptions, Tools, and Applications},
 series = {LDTA '12},
 year = {2012},
 isbn = {978-1-4503-1536-4},
 location = {Tallinn, Estonia},
 pages = {7:1--7:8},
 articleno = {7},
 numpages = {8},
 url = {http://doi.acm.org/10.1145/2427048.2427055},
 doi = {10.1145/2427048.2427055},
 acmid = {2427055},
 publisher = {ACM},
 address = {New York, NY, USA},
}
>>>
<<<
language composition;classification;theory;
>>>

<<<
Easing Program Comprehension by Sharing Navigation Data
>>>
<<<
comprehension/Easing Program Comprehension by Sharing Navigation Data.pdf;
>>>
<<<
Large software projects often require a programmer to make changes to unfamiliar source code. This paper describes a set of tools, called Team Tracks, designed to ease program comprehension by showing the source code navigation patterns of fellow development team members. One technique shows a list of  Related Items, given that the user is viewing a given method or class. Another technique shows the Favorite Classes, by showing a class hierarchy view that hides less frequently visited classes, methods, and members. Two user studies, a laboratory study and a field study, were run to evaluate the effectiveness of these techniques. The results of the two studies demonstrate that sharing navigation data can improve program comprehension and are subjectively preferred by users.

They got lost as they navigated around the code base, particularly as the number of open documents increased.

They relied heavily on textual search to find relevant parts of the code, lost time separating good search results from bad, and became distracted by results that seemed relevant but were not.
>>>
<<<
easingProgramComprehension
>>>
<<<
@INPROCEEDINGS{easingProgramComprehension, 
author={DeLine, R. and Czerwinski, Mary and Robertson, G.}, 
booktitle={Visual Languages and Human-Centric Computing, 2005 IEEE Symposium on}, 
title={{Easing program comprehension by sharing navigation data}}, 
year={2005}, 
month={Sept}, 
pages={241--248}, 
keywords={program visualisation;reverse engineering;Team Tracks;class hierarchy;navigation data sharing;program comprehension;software programming;software project;source code navigation pattern;Costs;Data visualization;Documentation;Fellows;Instruments;Laboratories;Navigation;Programming profession;Unified modeling language;Usability}, 
doi={10.1109/VLHCC.2005.32},}
>>>
<<<
program visualisation;reverse engineering;Team Tracks;class hierarchy;navigation data sharing;program comprehension;views;projections;study;
>>>

<<<
Theories, Methods and Tools in Program Comprehension: Past, Present and Future
>>>
<<<
comprehension/Storey - Theories, Methods and Tools in Program Comprehension.pdf;
>>>
<<<
Program comprehension research can be characterized by both the theories that provide rich explanations about how programmers comprehend software, as well as the tools that are used to assist in comprehension tasks. During this talk the author review some of the key cognitive theories of program comprehension that have emerged. Using these theories as a canvas, the author then explores how tools that are popular today have evolved to support program comprehension. Specifically, the author discusses how the theories and tools are related and reflect on the research methods that were used to construct the theories and evaluate the tools. The reviewed theories and tools will be further differentiated according to human characteristics, program characteristics, and the context for the various comprehension tasks. Finally, the author predicts how these characteristics will change in the future and speculate on how a number of important research directions could lead to improvements in program comprehension tools and methods.
>>>
<<<
surveyComprehension2005
>>>
<<<
@INPROCEEDINGS{surveyComprehension2005, 
author={Storey, Margaret-Anne}, 
booktitle={Proceedings of the 13th International Workshop on Program Comprehension, 2005}, 
title={{Theories, methods and tools in program comprehension: past, present and future}}, 
year={2005}, 
series={IWPC 2005},
month={May}, 
pages={181--191}, 
keywords={cognition;reverse engineering;software tools;human characteristics;program characteristics;program comprehension tools;Buildings;Computer science;Conferences;Electronic mail;History;Humans;Programming profession;Silver;Software engineering;Software tools}, 
doi={10.1109/WPC.2005.38}, 
ISSN={1092-8138},}
>>>
<<<
program comprehension;survey;methods;
>>>

<<<
Program comprehension during software maintenance and evolution
>>>
<<<
comprehension/von_mayrhauser95.pdf;
>>>
<<<
Code cognition models examine how programmers understand program code. The authors survey the current knowledge in this area by comparing six program comprehension models: the Letovsky (1986) model; the Shneiderman and Mayer (1979) model; the Brooks (1983) model; Soloway, Adelson and Ehrlich's (1988) top-down model; Pennington's (1987) bottom-up model; and the integrated metamodel of von Mayrhauser and Vans (1994). While these general models can foster a complete understanding of a piece of code, they may not always apply to specialized tasks that more efficiently employ strategies geared toward partial understanding. We identify open questions, particularly considering the maintenance and evolution of large-scale code. These questions relate to the scalability of existing experimental results with small programs, the validity and credibility of results based on experimental procedures, and the challenges of data availability.

opis viacerych modelov chapania programu, celkom fajn
>>>
<<<
programComprehension95
>>>
<<<
@ARTICLE{programComprehension95, 
author={von Mayrhauser, A. and Vans, A.M.}, 
journal={Computer}, 
title={Program comprehension during software maintenance and evolution}, 
year={1995}, 
month={Aug}, 
volume={28}, 
number={8}, 
pages={44--55}, 
doi={10.1109/2.402076}, 
ISSN={0018-9162},}
>>>
<<<
code cognition models;program code understanding;program comprehension models;scalability;software evolution;software maintenance;
>>>

<<<
What's in a Name? A Study of Identifiers
>>>
<<<
comprehension/What's in a Name A Study of Identifiers/IEEE Xplore Full-Text HTML   What's in a Name  A Study of Identifiers.html;
>>>
<<<
Readers of programs have two main sources of domain information: identifier names and comments. When functions are uncommented, as many are, comprehension is almost exclusively dependent on the identifier names. Assuming that writers of programs want to create quality identifiers (e.g., include relevant domain knowledge) how should they go about it? For example, do the initials of a concept name provide enough information to represent the concept? If not, and a longer identifier is needed, is an abbreviation satisfactory or does the concept need to be captured in an identifier that includes full words? Results from a study designed to investigate these questions are reported. The study involved over 100 programmers who were asked to describe twelve different functions. The functions used three different "levels" of identifiers: single letters, abbreviations, and full words. Responses allow the level of comprehension associated with the different levels to be studied. The functions include standard algorithms studied in computer science courses as well as functions extracted from production code. The results show that full word identifiers lead to the best comprehension; however, in many cases, there is no statistical difference between full words and abbreviations.

Zaujimava studia o pouziti identifikatorov, kraucke vs skratky vs cele nazvy, potvrdzuje ze cely nazov je v mnohych pripadoch lepsi
>>>
<<<
studyIdentifiers
>>>
<<<
@INPROCEEDINGS{1631100, 
author={Lawrie, D. and Morrell, C. and Feild, H. and Binkley, D.}, 
booktitle={Proceedings of the 14th IEEE International Conference on Program Comprehension, 2006}, 
title={{What's in a Name? A Study of Identifiers}}, 
year={2006}, 
series={ICPC 2006}
month={June}, 
pages={3--12}, 
keywords={reverse engineering;program comments;program comprehension;program identifier names;Code standards;Computer science;Data mining;Educational institutions;Natural languages;Production;Programming profession;Quality assessment;Software quality;Software systems}, 
doi={10.1109/ICPC.2006.51}, 
ISSN={1092-8138},}
>>>
<<<
identifiers;program comprehension;study;
>>>

<<<
Utilizing Web Search Engines for Program Analysis
>>>
<<<
comprehension/Utilizing Web Search Engines for Program Analysis/IEEE Xplore Full-Text HTML   Utilizing Web Search Engines for Program Analysis.html;
>>>
<<<
Programming involves representing domain concepts by using programming abstractions. In object-oriented programs, concepts and relations of the business domain are represented as classes, attributes and methods. However, the concepts and relations that logically belong together are scattered across different modules, interleaved with technical concepts, and distorted due to implementation details. In this paper, we present an automatic method to identify logically related concepts and the relations among them. To achieve this, we systematically transform program identifiers into fragments of natural language sentences and check whether these sentence fragments are meaningful for humans. In order to automatically perform such checks, we use the World Wide Web as a knowledge base that contains a huge number of meaningful texts, and use the Google web search engine to validate the meaningfulness of these sentences. If the search engine returns a sufficient number of hits, we discovered a piece of knowledge in the code. By systematically applying this method, we obtain a condensed form of the knowledge embodied in the program which is an enabler for automatic analyses. We present our experience with several use-cases: (1) assessing the meaningfulness of identifiers, (2) extracting complex concepts from compound identifiers, (3) extracting a meaningful taxonomy from the class hierarchy, and (4) extracting complex conceptual relations from the code. We report on our observations during the analysis of real world Java code, discuss the limitations of our approach and sketch extension possibilities.

asi jasne, extrahuju pomocou google vztahy medzi konceptami tym ze z faktov z kodu vytvaraju prirodzene vety a sleduju ako casto sa vyskytuju.. o co lepsie by bolo keby vztahy medzi konceptami uz boli vyjadrene anotaciamii (rovanka anotacia nad dvoma roznymi konceptami)
>>>
<<<
webSearchProgramAnalysis
>>>
<<<
@inproceedings{webSearchProgramAnalysis,
 author = {Ratiu, Daniel and Heinemann, Lars},
 title = {{Utilizing Web Search Engines for Program Analysis}},
 booktitle = {Proceedings of the 2010 IEEE 18th International Conference on Program Comprehension},
 series = {ICPC '10},
 year = {2010},
 isbn = {978-0-7695-4113-6},
 pages = {94--103},
 numpages = {10},
 url = {http://dx.doi.org/10.1109/ICPC.2010.26},
 doi = {10.1109/ICPC.2010.26},
 acmid = {1847954},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {concept location, program analysis, analysis of identifiers, domain knowledge},
}
>>>
<<<
code comprehension;identifiers;web search engines;reverse engineering;
>>>

<<<
Toward Intuitive Programming Languages
>>>
<<<
comprehension/Toward Intuitive Programming Languages/IEEE Xplore Full-Text HTML   Toward Intuitive Programming Languages.html;
>>>
<<<
Modern text-based computer programming languages use syntax, semantics, and APIs to represent actions a computer will perform. Historically, the design of these languages has largely escaped the critical gaze of peer review, relying more on expert opinions than robust scientific methodologies. In this paper, we pose a question - is it possible to create a programming language where the syntax, semantics, and API design is based upon rigorous data collection and the scientific method? We have undertaken a long-term project to develop a computer programming language, called Hop, where each language decision is based upon empirical metrics gathered from human studies. While such a design may not universally benefit all programmers, our hope is that such a procedure may make our community's language design decisions more objective and transparent.

robia jazyk tym ze sa pytaju ludi na kazdu cast.. napr vraj cez 600 percent ludi tvrdi ze repeat je vhodnejsie nez for alebo while a intuitivnejsie
>>>
<<<
intuitiveProgLanguages
>>>
<<<
@INPROCEEDINGS{intuitiveProgLanguages, 
author={Stefik, A. and Siebert, S. and Slattery, K. and Stefik, M.}, 
booktitle={Proceedings of the 2011 IEEE 19th International Conference on Program Comprehension}, 
series = {ICPC 2011}
title={{Toward Intuitive Programming Languages}}, 
year={2011}, 
month={June}, 
pages={213--214}, 
keywords={application program interfaces;programming language semantics;programming languages;API;Hop language;data collection;empirical metrics;intuitive programming language;language design decision;scientific method;semantics;syntax;text-based computer programming language;Computer languages;Computers;Humans;Measurement;Programming;Semantics;Syntactics;empirical studies;intuitiveness;programming languages;syntax}, 
doi={10.1109/ICPC.2011.33}, 
ISSN={1092-8138},}
>>>
<<<
comprehension;languages;language design;intuitive programming language;
>>>

<<<
The Influence of the Task on Programmer Behaviour
>>>
<<<
comprehension/The Influence of the Task on Programmer Behaviour/IEEE Xplore Full-Text HTML   The Influence of the Task on Programmer Behaviour.html;
>>>
<<<
Programmers performing a change task must understand the existing software in addition to performing the actual change. This process is likely to be affected by characteristics of the task. We investigated whether the nature of a task has any relationship with when a programmer edits code during a programming session. We characterized differences in editing behaviour with three types of editing styles: edit-first, edit-last, and edit-throughout. We based our analysis on the interaction history of over 4000 programming sessions collected as part of the development history of open source projects. Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session. To our surprise, we also found that the presence of a stack trace in a bug report did not significantly effect the editing style of the programming session.

Such theories hint at the significance of timing of coding activity in a programming task. 

related work by sa nasla praca ktora opisuje dolovanie informacii o vztahoch z logovania interakcie a navigacie

Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session.

da sa to pouzit ako motivator editable views
>>>
<<<
taskProgrammerBehaviour
>>>
<<<
@INPROCEEDINGS{taskProgrammerBehaviour, 
author={Ying, A.T.T. and Robillard, M.P.}, 
booktitle={Proceedings of the 2011 IEEE 19th International Conference on Program Comprehension}, 
series = {ICPC 2011},
title={{The Influence of the Task on Programmer Behaviour}}, 
year={2011}, 
month={June}, 
pages={31--40}, 
keywords={behavioural sciences;program debugging;programming;software engineering;bug fix;bug report;development history;edit-first style;edit-last style;edit-throughout style;editing behaviour;editing style;enhancement task;interaction history;open source projects;programmer behaviour;programming session;source code editing;stack trace;Clustering algorithms;Couplings;History;Monitoring;Navigation;Programming;Software;Development interaction history;Mining software archives;Program comprehension}, 
doi={10.1109/ICPC.2011.35}, 
ISSN={1092-8138},}
>>>
<<<
views;program comprehension;maintenance;study;projections;
>>>

<<<
Software Comprehension through Concern-based Queries
>>>
<<<
comprehension/Software Comprehension through Concern-based Queries/IEEE Xplore Full-Text HTML   Software Comprehension through Concern-based Queries.html;
>>>
<<<
A concern-based approach to support software comprehension and analysis is proposed. Concerns represent various aspects of a system, like features, architectural solutions, units of work, etc., which are interesting for some stakeholders. Using concern-based queries on the software artefacts, new derived information on the system can be exposed. The results of the queries are also represented as concerns and added to the concern repository. The approach thus supports the analyzer in gradually building up an understanding on the subject system to be analyzed.

ak to spravne chapem snazia sa dopytovat na vztahy medzi artefaktami systemu pomocou queries ktore sa tykaju nejakeho daneho concernu, robia to nad uml (cize zrejme nieco podobne ako chceme my s anotaciami)

As concerns themselves are abstract and disconnected from the actual software system, we need a concern mapping that binds the concerns to the subject system. This mechanism consists of identifying the software artefacts (UML models in our case) to be included in the concern and binding them to the concern.
The identification of the elements to be included in a concern typically involves manual activities, since a concern is always a viewpoint of a stakeholder. Thus, a manual selection tool for building a concern is necessarily required. In some cases, however, many of the elements belonging to a concern can be identified on the basis of some structural conditions. In such cases, a large portion of the concern can be mapped automatically using a tool that finds the elements satisfying the condition, and binds them to a draft concern that can be further edited manually (for example by adding or removing elements). As an example, the view classes participating in an MVC pattern often have “view” as part of their names. Thus, the tool can find potential participants of a “GUI Display” concern by searching for classes whose names match with a regular expression. We have implemented this kind of simple tool support, but other (semi)automated means to identify the concerns could be developed as well. This remains as a part of our future research.
>>>
<<<
concernQueries
>>>
<<<
@INPROCEEDINGS{concernQueries, 
author={Reinikainen, T. and Hammouda, I. and Laiho, J. and Koskimies, K. and Systa, T.}, 
booktitle={Proceedings of the 2007 IEEE 15th IEEE International Conference on Program Comprehension}, 
title={{Software Comprehension through Concern-based Queries}}, 
year={2007}, 
month={June}, 
series ={ICPC '07},
pages={265--270}, 
keywords={query processing;reverse engineering;software engineering;concern-based queries;software artefacts;software comprehension;Cognitive science;Concrete;Data mining;Libraries;Reverse engineering;Set theory;Software systems;Software tools;Unified modeling language;XML}, 
doi={10.1109/ICPC.2007.36}, 
ISSN={1092-8138},}
>>>
<<<
UML;views;projections;program comprehension;concern;
>>>

<<<
Programming from the Reader's Perspective: Toward an Expectations Approach
>>>
<<<
comprehension/Programming from the Reader's Perspective Toward an Expectations Approach/IEEE Xplore Full-Text HTML   Programming from the Reader's Perspective  Toward an Expectations Approach.html;
>>>
<<<
There are many guidelines for composing programs, but few methodologies take into account the expectations readers have when reading an unfamiliar program. As a result, code that seems well-written and clear to the developer might not be read and interpreted by the reader in the way the programmer expected. We conducted a survey of Java programmers to determine how a program's structure may signal subjective cues to the reader. We found that the use of meaning-preserving program refactorings had a measurable effect on what readers believed the programmer's main intention was.

The most readable code had comments and external procedures; this made the code longer to read, but it included more structure and clues and hence was more readable. Our study takes a similar approach, but rather than asking questions about the code with objective answers, we asked for subjective interpretations (selected from a list provided) of the code, that considers how a program's structure gives cues to readers about the developer's possible intentions.

struktura indikuje co chcel autor urobit a ma tak podstatny vplyv na to ako clovek chape taky kod ak nie j ejeho, to znaznacuje ze ludia stavaju na beaconoch a ze im pripisuju intuitivne vyznam!!!

Overwhelmingly, the descriptions that matched names used in the code were picked as most likely matching the programmer's intentions. Interestingly, removing descriptive names lead to the highest success in finding the correct description.
>>>
<<<
readersPerspective
>>>
<<<
@INPROCEEDINGS{readersPerspective, 
author={Samaraweera, G. and Shonle, M. and Quarles, J.}, 
booktitle={Proceedings of the 2011 IEEE 19th International Conference on Program Comprehension}, 
series={ICPC 2011},
title={{Programming from the Reader's Perspective: Toward an Expectations Approach}}, 
year={2011}, 
month={June}, 
pages={211--212}, 
keywords={Java;programming;software maintenance;Java program;expectations approach;meaning-preserving program refactoring;program composition;program structure;programming;Analytical models;Conferences;Guidelines;Java;Programming;Semantics;Writing}, 
doi={10.1109/ICPC.2011.32}, 
ISSN={1092-8138},}
>>>
<<<
study;program comprehension;explicitness;views;projections;program readability;
>>>

<<<
Partial Domain Comprehension in Software Evolution and Maintenance
>>>
<<<
comprehension/Partial Domain Comprehension in Software Evolution and Maintenance/IEEE Xplore Full-Text HTML   Partial Domain Comprehension in Software Evolution and Maintenance.html;
>>>
<<<
Partial comprehension is a necessity in the evolution and maintenance of very large software systems. The programmers form not only partial comprehension of the code, but also partial comprehension of the application domain. To describe the comprehension process, we introduce ontology fragments and investigate how programmers form, use and extend them before and during concept location; concept location is a prerequisite of code changes. We conducted case studies of concept location in two large systems, Eclipse and Mozilla, that both have more than 50,000 methods. Using grep search and ontology fragments, the programmers were able to locate the concepts after inspecting on average less than 10 methods and operating with ontology fragments of around 14 concepts, a very small fraction of the total.

domenove znalosti beu tiez do uvahy pri parcialnom pochopeni, ako sa mapuje dom. na kod

However, the code is hard to understand and therefore the programmers prefer to construct a preliminary and perhaps inaccurate understanding of the application domain by first exploring other available sources [9]. These may include exploring the GUI, trying various features of the program, or reading whatever documentation may be available. Only then, the programmers attempt to match the collected knowledge to the code.

Concepts location -- For that, the programmers first identify the concepts related to the change request and then, using search tools, query the code to find the components that implement these concepts. It is important to note that, while some concepts are directly implemented as one or more of program components, other concepts might be only assumed in the code or represented collectively through a group of other concepts; we say that the concepts from the first group are explicit concepts, while the second group represents implicit concepts

opis experimentov s dvomi ludmi
>>>
<<<
partialDomainComprehension
>>>
<<<
@INPROCEEDINGS{partialDomainComprehension, 
author={Petrenko, M. and Rajlich, V. and Vanciu, R.}, 
booktitle={Proceedings of the 16th IEEE International Conference on Program Comprehension}, 
title={{Partial Domain Comprehension in Software Evolution and Maintenance}}, 
series={ICPC 2008},
year={2008}, 
month={June}, 
pages={13--22}, 
keywords={ontologies (artificial intelligence);reverse engineering;software maintenance;Eclipse;Mozilla;concept location;grep search;ontology fragments;partial domain comprehension;software evolution;software maintenance;Application software;Computer architecture;Computer science;Documentation;Navigation;Ontologies;Programming profession;Software maintenance;Software systems;Vocabulary;Comprehension;Concept Location;Domain;Ontology;Ontology Fragments;Partial;Software Evolution;Software Maintanence}, 
doi={10.1109/ICPC.2008.14}, 
ISSN={1092-8138},}
>>>
<<<
experiment;study;program comprehension;mapping;concern;
>>>

<<<
From Reality to Programs and (Not Quite) Back Again
>>>
<<<
comprehension/From Reality to Programs and (Not Quite) Back Again/IEEE Xplore Full-Text HTML   From Reality to Programs and (Not Quite) Back Again.html;
>>>
<<<
Making explicit the mappings between real-world concepts and program elements that implement them is an essential step in understanding, using or evaluating the public interface of programs, libraries and other collections of classes that model core domain concepts. Unfortunately, due to the big abstraction gap between the modeled domain and today's programming languages, the mapping is most of the times ambiguous as concepts and relations from the real world are distorted and diffused in the code. In this paper we present a comprehensive formal framework for describing the many-to-many mappings between domain concepts and the program elements, real-world relations and program relations and the real-world concept names and program identifiers. This framework allows us to describe and discuss typical classes of diffusion of the domain knowledge in code. Based on our formal framework we describe an algorithm to recover the mappings between entities from an ontology and program elements. We illustrate the framework by using examples from the Java standard library.

mapovanie medzi conceptual, lexical and program layers -- concept - name - word- identifier - program element

diffusion of concepts - v podstate to je o tom ako sa moze jeden koncept rozptylit v implmentacii
diffusion of names - ako sa moze sprznit pomenovanie identifikatorov
diffusion of relations

v podstate zobrazju ontologiu na zdrojovy kod a hovoria o nejakych pripadoch kedy sa to diffusuje, co je asi zle
>>>
<<<
realityToPrograms
>>>
<<<
@INPROCEEDINGS{realityToPrograms, 
author={Ratiu, D. and Deissenboeck, F.}, 
booktitle={Proceedings of the 15th IEEE International Conference on Program Comprehension}, 
title={{From Reality to Programs and (Not Quite) Back Again}}, 
year={2007}, 
series={ICPC '07},
month={June}, 
pages={91--102}, 
keywords={Java;digital libraries;ontologies (artificial intelligence);programming languages;user interfaces;Java standard library;formal framework;many-to-many mappings;programming languages;public interface;Bridges;Computer languages;Humans;Java;Libraries;Ontologies;Programming profession;Scattering;Shape;Usability}, 
doi={10.1109/ICPC.2007.22}, 
ISSN={1092-8138},}
>>>
<<<
experiment;study;program comprehension;mapping;ontology;
>>>

<<<
From Program Comprehension to People Comprehension
>>>
<<<
comprehension/From Program Comprehension to People Comprehension/IEEE Xplore Full-Text HTML   From Program Comprehension to People Comprehension.html;
>>>
<<<
Large-scale software engineering requires many teams to collaborate together to create software products. The problems these teams suffer trying to coordinate their joint work can be addressed through tools inspired by social networking. Social networking tools help people to more easily discover and more efficiently maintain relationships than is feasible using one-to-one or face-to-face interactions. Applying these ideas to the software domain requires new kinds and combinations of software program and process analyses that overcome intrinsic limitations in the accuracy of the underlying data sources and the ambiguity inherent in human relationships.

v jednoduchosti, nejaky socialny network pre koderov ktory im umoznuje byt updatovany na to co sa deje v time a co moze ovplyvnit ich rpacu (odberatel ich kodu, dodavatel, atd)
>>>
<<<
peopleComprehension
>>>
<<<
@inproceedings{peopleComprehension,
 author = {Begel, Andrew},
 title = {{From Program Comprehension to People Comprehension}},
 booktitle = {Proceedings of the 2010 IEEE 18th International Conference on Program Comprehension},
 series = {ICPC '10},
 year = {2010},
 isbn = {978-0-7695-4113-6},
 pages = {190--191},
 numpages = {2},
 url = {http://dx.doi.org/10.1109/ICPC.2010.42},
 doi = {10.1109/ICPC.2010.42},
 acmid = {1847966},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {software process, human aspects},
}
>>>
<<<
tools;social networking;code comprehension;microsoft;study;
>>>

<<<
Faceted Navigation for Software Exploration
>>>
<<<
comprehension/Faceted Navigation for Software Exploration/IEEE Xplore Full-Text HTML   Faceted Navigation for Software Exploration.html;
>>>
<<<
Much of developers' time is spent in exploring and understanding an unfamiliar software space. In this paper, we present a novel approach that characterizes the code fragments along several orthogonal dimensions in order for developers to navigate complex software spaces in a flexible manner. Central to our approach are hierarchical faceted categories (HFC), which have become especially successful in supporting exploratory web search activities. We apply the HFC approach for exploring a sizeable open-source software system. Our preliminary evaluation shows that HFC are promising in supporting software exploration tasks.

The concept assignment problem [1] is one of the major challenges for effectively exploring the code base. It refers to the mismatch between the programmer's intentional strategies to fulfill maintenance goals and the implementation-level navigational links provided in contemporary SDEs (syntax directed editors).

 In this paper, we argue in favor of a novel software exploration approach, where code fragment's purpose and intent are tagged with a hierarchical faceted scheme, guiding the developers to navigate explicitly along conceptually rich dimensions.

facet je akoby perspektiva, alebo jeden velky concern, v ktorom su potom kategorie (podkoncerny). Vyzera to tak ze v ramci facetu jeden prvok nmoze spadat pod viacerych kategorii, moze v ramci viacerych facetoch

HFC can be beneficial when the developer's queries are vague, ambiguous, broad, open-ended, or not easily expressed in a keyword search.
HFC provide the users the ability to find items based on more than one dimension, not only via multiple entry points but also through a linear progression with successive filtering of retrieved items.
HFC can offer the developer a semantic peripheral view of the software's content. This provides cues for code fragment's relevance to developer's maintenance goals. Faceted navigation reveals what is available and what is not, and lets developers know whether they are exploring the right topic.
HFC can enable the developer to make new connections about the software space, suggesting logical but perhaps unexpected alternatives at every exploration, while at the same time helping developer avoid the feelings of being lost.

nejake taketo faceotovane mapovanie by malo vraj pomaaht ludom lahsie vyhladat informacie (inspirovane haldanim vo webe)
>>>
<<<
facetedNavigation
>>>
<<<
@INPROCEEDINGS{facetedNavigation, 
author={Nan Niu and Mahmoud, A. and Xiaoyong Yang}, 
booktitle={Proceedings of the 2011 IEEE 19th International Conference on Program Comprehension}, 
series = {ICPC 2011},
title={{Faceted Navigation for Software Exploration}}, 
year={2011}, 
month={June}, 
pages={193--196}, 
keywords={data flow analysis;public domain software;complex software spaces;exploratory Web search activities;faceted navigation;hierarchical faceted categories;open-source software system;software exploration;Computer science;Hybrid fiber coaxial cables;Navigation;Open source software;Usability;Web search;code navigation;exploratory search;faceted navigation;faceted search;software exploration}, 
doi={10.1109/ICPC.2011.18}, 
ISSN={1092-8138},}
>>>
<<<
experiment;study;projections;views;comprehension;
>>>

<<<
Interaction between prior knowledge and concept-map structure on hypertext comprehension, coherence of reading orders and disorientation
>>>
<<<
comprehension/Interaction between prior knowledge and concept-map structure on hypertext comprehension, coherence of reading orders and disorientation.pdf;
>>>
<<<
The study examined the interaction effects of prior knowledge and hypertexts structure (network vs. hierarchy) on comprehension. Comprehension was investigated analyzing jointly three dependent variables: comprehension outcomes, coherence of the reading sequences and feelings of disorientation. The results supported most of the assumptions showing an interaction effect on each measure. For low prior knowledge readers, a hierarchical structure improved comprehension performance, helped them to follow coherent reading sequences and reduced their feelings of disorientation. For high prior knowledge readers, comprehension performance and feelings of disorientation were not affected by the type of structure. Moreover, prior knowledge was a relevant resource to cope with the cognitive requirements of reading non-linear texts. In the network condition, prior knowledge supported better comprehension, led the readers to follow more coherent reading sequences and limited their feelings of disorientation. The discussion dealt with processes based on prior knowledge involved in hypertext comprehension, and stressed the need for conducting further investigations on the nature of the on-line inferences and on relations between performance, navigation and disorientation.

pouzitelne ze ak clovek nepozna kod, tak sa mu lepsie cita koherentne, ak je spolu (chceme zobrazit kod spolu napriek tomu ze je prepojeny pomocou anotacii)
>>>
<<<
hypertextReadingComprehension
>>>
<<<
@article{hypertextReadingComprehension,
 author = {Amadieu, Franck and Tricot, Andr{\'e} and Marin{\'e}, Claudette},
 title = {{Interaction Between Prior Knowledge and Concept-map Structure on Hypertext Comprehension, Coherence of Reading Orders and Disorientation}},
 journal = {Interacting with Computers},
 issue_date = {March, 2010},
 volume = {22},
 number = {2},
 month = mar,
 year = {2010},
 issn = {0953-5438},
 pages = {88--97},
 numpages = {10},
 url = {http://dx.doi.org/10.1016/j.intcom.2009.07.001},
 doi = {10.1016/j.intcom.2009.07.001},
 acmid = {1747020},
 publisher = {Elsevier Science Inc.},
 address = {New York, NY, USA},
 keywords = {Coherence, Comprehension, Concept map, Disorientation, Hypertext, Prior knowledge},
}
>>>
<<<
Coherence;Comprehension;Concept map;Disorientation;Hypertext;Prior knowledge;projections;views;
>>>

<<<
The concept assignment problem in program understanding
>>>
<<<
comprehension/The concept assignment problem in program understanding.pdf;
>>>
<<<
A person understands a program because they are able to relate the structures of the program and its environment to their human oriented conceptual knowledge about the world. The problem of discovering individual human oriented concepts and assigning them to their implementation oriented counterparts for a given program is the concept assignment problem. We will argue that the solution to this problem requires methods that have a strong plausible reasoning component. We will illustrate these ideas through example scenarios using an existing design recovery system called DESIRE. Finally, we will evaluate DESIRE based on its usage on real-world problems over the years.
>>>
<<<
conceptAssignment
>>>
<<<
@inproceedings{conceptAssignment,
 author = {Biggerstaff, Ted J. and Mitbander, Bharat G. and Webster, Dallas},
 title = {{The Concept Assignment Problem in Program Understanding}},
 booktitle = {Proceedings of the 15th International Conference on Software Engineering},
 series = {ICSE '93},
 year = {1993},
 isbn = {0-89791-588-7},
 location = {Baltimore, Maryland, USA},
 pages = {482--498},
 numpages = {17},
 url = {http://dl.acm.org/citation.cfm?id=257572.257679},
 acmid = {257679},
 publisher = {IEEE Computer Society Press},
 address = {Los Alamitos, CA, USA},
 keywords = {concept recognition, connectionist, domain, knowledge base, plausible reasoning, reverse engineering, slicing},
}
>>>
<<<
concept recognition;concept assignment;concept location;program comprehension;
>>>

<<<
The Role of Concepts in Program Comprehension
>>>
<<<
comprehension/Rajlich.IWPC.2002.RoleOfConcepts.pdf;
>>>
<<<
The paper presents an overview of the role of concepts in program comprehension. It discusses concept location, in which the implementation of a specific concept is located in the code. This process is very common and precedes a large proportion of code changes. The paper also discusses the process of learning about the domain from the code, which is aprerequisite of code reengineering. The paper notes the similarities and overlaps between program comprehension and human learning.

concept location -- process od domeny ku kodu
concept assignment-- v podstate opacny proces

as-needed strategy namiesto top-down alebo bottom-up

We should be aware that several simplified definitions of what is a concept appear in the literature. One is the popular idea that concepts are equivalent to objects in an object-oriented program. While it is true that in a well-structured object oriented program each class represents a concept (external viewer, credit card, and so on), the opposite is not true. There are many concepts of the program domain that are too trivial to have a class of their own. For example, the concept “payment” may be implemented as a single integer within class “sale” rather than having its own class.  Also, many concepts are spread across several classes.

In our work, we use the following working definition:  
Concepts are units of human knowledge that can be processed by the human mind (short-term memory) in one instance.  
Thus we would include in our definition both domain concepts that would be familiar to an end user ("credit card payment") as well as related high level design concepts ("iterator pattern used in the list of credit card holders"), and important error conditions that a user may be only dimly aware of ("network error while validating credit card").

concept location moze byt ovplyvneny strukturou (jeden clanok na to som cital, aj v poznamke je struktura spomenuta) a tak neznama struktura moze ovplynit neznaleho cloveka pri identifikacii lokacie nejakeho kodu. anotacie umoznuju taketo problemy aspon ciastocne preklenut (plus samozrejme ten fakt ze vieme kod zobrazit naraz, kohoerentne)
>>>
<<<
conceptsComprehension
>>>
<<<
@inproceedings{conceptsComprehension,
 author = {Rajlich, V\'{a}clav and Wilde, Norman},
 title = {{The Role of Concepts in Program Comprehension}},
 booktitle = {Proceedings of the 10th International Workshop on Program Comprehension},
 series = {IWPC '02},
 year = {2002},
 isbn = {0-7695-1495-2},
 pages = {271--},
 url = {http://dl.acm.org/citation.cfm?id=580131.857012},
 acmid = {857012},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
}
>>>
<<<
program comprehension;comprehension models;concept location;projections;views;
>>>

<<<
DynaRIA: A Tool for Ajax Web Application Comprehension
>>>
<<<
comprehension/DynaRIA A Tool for Ajax Web Application Comprehension/IEEE Xplore Full-Text HTML   Comprehending Ajax Web Applications by the DynaRIA Tool.html;
>>>
<<<
Thanks to Rich Internet Applications (RIAs) with their enhanced interactivity, responsiveness and dynamicity, the user experience in the Web 2.0 is becoming more and more appealing and user-friendly. At the same time, the dynamic nature of RIAs, and the heterogeneous technologies, frameworks, communication models used for implementing them negatively affect their analyzability and understandability, so that specific software techniques and tools are needed for supporting their comprehension. This paper presents DynaRIA, a tool for the comprehension of RIAs implemented in Ajax that is based on dynamic analysis and provides functionalities for recording and analyzing user sessions from several perspectives, and producing various types of abstractions and visualizations about the run-time behaviour of the application.

sleduje interakciu pouzivaela s aplikaciou v integrovanom web browseri a loguje co sa deje.. vie z toho generovat diagramy, vie aj nahravat udalosti a opakovat ich pre potreby testovania a debugovania
>>>
<<<
dynaRia
>>>
<<<
@INPROCEEDINGS{dynaRia, 
author={Amalfitano, D. and Fasolino, A.R. and Polcaro, A. and Tramontana, P.}, 
booktitle={Proceedings of the 2010 IEEE 18th International Conference on Program Comprehension},
series={ICPC 2010}, 
title={{DynaRIA: A Tool for Ajax Web Application Comprehension}}, 
year={2010}, 
month={June}, 
pages={46--47}, 
keywords={Internet;program visualisation;software tools;user interfaces;Ajax Web application comprehension;DynaRIA;Web 2.0;communication models;dynamic analysis;heterogeneous technologies;rich Internet applications;run-time behaviour;software techniques;software tools;user sessions;Communications technology;Delay;Internet;Java;Runtime;Search engines;Software tools;US Department of Transportation;User interfaces;Visualization;AJAX Application;Dynamic Analysis;Program Comprehension Tool;Reverse Engineering;Rich Internet Applications}, 
doi={10.1109/ICPC.2010.16}, 
ISSN={1092-8138},}
>>>
<<<
DynaRIA;program comprehension;web;AJAX;
>>>

<<<
Can Better Identifier Splitting Techniques Help Feature Location?
>>>
<<<
comprehension/Can Better Identifier Splitting Techniques Help Feature Location/IEEE Xplore Full-Text HTML   Can Better Identifier Splitting Techniques Help Feature Location .html;
>>>
<<<
The paper presents an exploratory study of two feature location techniques utilizing three strategies for splitting identifiers: Camel Case, Samurai and manual splitting of identifiers. The main research question that we ask in this study is if we had a perfect technique for splitting identifiers, would it still help improve accuracy of feature location techniques applied in different scenarios and settings? In order to answer this research question we investigate two feature location techniques, one based on Information Retrieval and the other one based on the combination of Information Retrieval and dynamic analysis, for locating bugs and features using various configurations of preprocessing strategies on two open-source systems, Rhino and jEdit. The results of an extensive empirical evaluation reveal that feature location techniques using Information Retrieval can benefit from better preprocessing algorithms in some cases, and that their improvement in effectiveness while using manual splitting over state-of-the-art approaches is statistically significant in those cases. However, the results for feature location technique using the combination of Information Retrieval and dynamic analysis do not show any improvement while using manual splitting, indicating that any preprocessing technique will suffice if execution data is available. Overall, our findings outline potential benefits of putting additional research efforts into defining more sophisticated source code preprocessing techniques as they can still be useful in situations where execution information cannot be easily collected.

Identifiers used by programmers as names for classes, methods, or attributes in source code or other artifacts contain vital problem domain information [2] [4] [7] [15] [18] [23] [28] [34] and account for approximately more than half the source code in software [7]. 

nieco o feature location, to je pdobne ako koncept location

v podastate na feature location sa pouziva nejaky information retrieval algorithm ktory je v spojeni s algoritmami na idetntifier splitting, oni si polozili otazku (hypotezu) ci dokonaly algoritmus pre splitting nejako ovplyvni efektivnost lokacie features; na to zobrali niekolko existujucich algoritmov a testovali ich spolu s tym, ked splittli tie identifikatory manualne

to vlastne aj hovoi o reoli nestrukturovanych informacii v programe, identifikatory totizto su volne strukturovane (konvencia)
>>>
<<<
identifierSplitting
>>>
<<<
@INPROCEEDINGS{identifierSplitting, 
author={Dit, B. and Guerrouj, Latifa and Poshyvanyk, D. and Antoniol, G.}, 
booktitle={Proceedings of the 2011 IEEE 19th International Conference on Program Comprehension}, 
title={{Can Better Identifier Splitting Techniques Help Feature Location?}}, 
series={ICPC},
year={2011}, 
month={June}, 
pages={11--20}, 
keywords={information retrieval;CamelCase;Rhino;Samurai;feature location technique;identifier splitting technique;information retrieval;jEdit;open source system;preprocessing strategies;Accuracy;Algorithm design and analysis;Dictionaries;Gold;Large scale integration;Manuals;Software;dynamic analysis;feature location;identifier splitting algorithms;information retrieval}, 
doi={10.1109/ICPC.2011.47}, 
ISSN={1092-8138},}
>>>
<<<
identifiers;program comprehension;feature location;concept location;study;experiment;
>>>

<<<
Building Usage Contexts During Program Comprehension
>>>
<<<
comprehension/Building Usage Contexts During Program Comprehension/IEEE Xplore Full-Text HTML   Building Usage Contexts During Program Comprehension.html;
>>>
<<<
Software developers often work on multiple simultaneous projects. Even when only a single project is underway, everyday distractions interrupt the development effort. Consequently, developers spend significant effort pursuing recovery of their context. By context, we focus on the classes and methods within the code that are relevant to a specific bug being fixed or enhancement made. Context is reified by a program in terms of a set of presentations (windows a containing source code, command executions, and data files); however, it is not enough to save the latest context. Even when working on a single task, programmers flip between contexts as they extend their understanding, and when they decide on a change, they may have to visit several contexts in order to address all possible ripple effects. Consequently, we would like to record a history of contexts and be able to retrieve them as demanded by the current task. We introduce a novel technique to obtain a context, consisting of a set of methods relevant for the current task, from a programmer's interactions with an IDE. Using this context, we demonstrate how to improve the ability of a programmer to recover the mental state associated with tasks and to facilitate the exploration of software through recommendation systems

tiez sa tu spominaju nastroje logujuce navigaciu na vytvraanie possible relations between concepts

zda sa aze oni to robia temporalne, ze sleduju aktualny kontext v danom casovom okamziku, a tak nie len globalne prepojenie konceptov, ale aj take aspektove -- niekedy je proste pre cloveka zaujimava ina spojitost nez inokedy

The elements of the context would serve as a way for the programmer to reinstate their mental context after a period of distraction, or reducing the cognitive load and disorientated associated with performing a search. 

Some possible applications of context can be used in the following manner:
to recover the mental state of a programmer after disorientation,
as filters in software engineering tools,
in recommendation systems to recover mental state and facilitate exploration,
to recover the methods of past tasks.

loguju interakciu pouzivatela s IDE a z tejto interakcnej historie chcu vytvarat kontexty, interakcia je vo forme eventov nad kodom, navstivenie metody a pod., chcu vsak aj vediet detegovat vyznam kazdej tranzicie, totiz niekedy je to preklik alebo sa ukaze ze otveorena metoda nie je suvisiaca - zda sa ze tam maju nejae heuristiky. tak isto hovoria o prefetchnig, ktory zabezpecuje ze recommendations ponuknu aj metody predtym nenavstivene (spojenie kontextu s klasickymi recommenndations systemami)
urobili aj case study s visualkom na 30 dni na nejakom projekte (projektoch, 10 ludi, nejaky na defence contracor), nalayzovali ako vedel ich nastroj predpovedat vhodne metody, ale aj efektivitu roznych algoritmov na nahradzovanie a prefetching

The summary of our evaluation of data is as follows:
95% of transitions were to methods a programmer has previously visited in the day.
Using a context of size four with LRU replacement, 69% of previously visited methods residing in another class were able to be recovered from the context.
The best method of recovering previously accessed methods was to discard the least recently used method from a context.
The prediction power of a recommendation system may be boosted to 2–3 times the inter-class transition hit rate, and to 3–5 times the explore transition rate while retaining a superior recovery rate compared with a traditional recommendation system.
>>>
<<<
usageContexts
>>>
<<<
@INPROCEEDINGS{usageContexts, 
author={Parnin, C. and Gorg, C.}, 
booktitle={Proceedings of the 2006 IEEE 14th International Conference on Program Comprehension}, 
series = {ICPC},
title={{Building Usage Contexts During Program Comprehension}}, 
year={2006}, 
pages={13--22}, 
keywords={human factors;project management;reverse engineering;software engineering;IDE;program bug;program comprehension;program usage context;programmer interaction;recommendation system;software project development;Context modeling;Educational institutions;Energy resolution;History;Organizing;Programming profession;Software systems}, 
doi={10.1109/ICPC.2006.14}, 
ISSN={1092-8138},}
>>>
<<<
program comprehension;tools;context recovery;projections;views;IDE;navigation;
>>>

<<<
Automatic generation of natural language summaries for Java classes
>>>
<<<
comprehension/Automatic generation of natural language summaries for Java classes/IEEE Xplore Full-Text HTML   Automatic generation of natural language summaries for Java classes.html;
>>>
<<<
Most software engineering tasks require developers to understand parts of the source code. When faced with unfamiliar code, developers often rely on (internal or external) documentation to gain an overall understanding of the code and determine whether it is relevant for the current task. Unfortunately, the documentation is often absent or outdated. This paper presents a technique to automatically generate human readable summaries for Java classes, assuming no documentation exists. The summaries allow developers to understand the main goal and structure of the class. The focus of the summaries is on the content and responsibilities of the classes, rather than their relationships with other classes. The summarization tool determines the class and method stereotypes and uses them, in conjunction with heuristics, to select the information to be included in the summaries. Then it generates the summaries using existing lexicalization tools. A group of programmers judged a set of generated summaries for Java classes and determined that they are readable and understandable, they do not include extraneous information, and, in most cases, they are not missing essential information.

Existing studies [1] revealed that developers often spend more time searching, browsing, and reading the code than editing it.

pouzivaju heuristiky a nejake stereotypy metod a tried na generovanie dokumentacie, tie stereotypy taktiez pouzivaju na sablony, je to silne zavisle na kvalite identifikatorov - celkom dobre to vyzera
urobili aj evaluation s 20 studentami, co je ale zaujimave tiez im rozhadzovali rozne popisy, ze nie kazdy to iste mal robit -- nie len ze ti ludia museli ohodnotit ich summary, ale aj sami mali napisat aby sa ukazalo ci to aj sami pochopil, zhodnotili aj to ze ktore stereotypy mali najvacsiu a ktore najmensiu uspesnost
>>>
<<<
naturalSummariesJavaClasses
>>>
<<<
@INPROCEEDINGS{naturalSummariesJavaClasses, 
author={Moreno, L. and Aponte, J. and Sridhara, G. and Marcus, A. and Pollock, L. and Vijay-Shanker, K.}, 
booktitle={Proceedings of the 2013 IEEE 21st International Conference on Program Comprehension}, 
title={{Automatic generation of natural language summaries for Java classes}}, 
year={2013}, 
series={ICPC 2013},
month={May}, 
pages={23--32}, 
keywords={Java;natural language processing;software engineering;system documentation;Java classes;automatic generation;essential information;external documentation;human readable summary;internal documentation;lexicalization tools;natural language summary;software engineering tasks;source code;stereotypes;summarization tool;Context;Documentation;Educational institutions;Java;Natural languages;Production facilities;Taxonomy;Source code summarization;documentation generation;program comprehension}, 
doi={10.1109/ICPC.2013.6613830}, 
ISSN={1063-6897},}
>>>
<<<
program comprehension;browsing;searching;Java;documentation generation;class stereotypes;method stereotypes;API documentation;
>>>

<<<
A Non-conservative Approach to Software Pattern Detection
>>>
<<<
comprehension/A Non-conservative Approach to Software Pattern Detection/IEEE Xplore Full-Text HTML   A Non-conservative Approach to Software Pattern Detection.html;
>>>
<<<
Pattern detection in software systems is one of several collaborating techniques for reverse engineering and program comprehension. Unfortunately, it is a hard problem in both theory and practice. A recent method to increase efficiency is based on conservatively filtering edges of a software system's structure graph, i.e., only removing edges guaranteed not to be part of any pattern instance. This leads to planar graphs in many cases allowing for efficient matching algorithms. This paper shows the feasibility of a non-conservative filtering approach, where even edges possibly part of a pattern instance can be removed to reach planarity. We show theoretically that not only decreased accuracy is possible due to non-conservative filtering, but also increased accuracy. We also perform an experimental evaluation supporting this statement. The paper complements the safe filtering method and together the two approaches allow for efficient pattern detection for all systems and patterns.

vyzera to tak ze deteguju design patterns aby mohli podporit chapanie programu, takze v podstate naznacuju to co som ja predpokladal ze struktura je medzikrok a ze clovek rychlejsie chape kod ked je v nom schopny detegovat nejaky jemu znamy pattern

idea je takato, existuju metody vytvarania planarnych grafov z nejakych grafov zo struktury, ktore umoznuju lahsie detegovat vzory (pomocou nejakych algoritmov), ale obcas nedokazu urobit uplne planarny graf, lebo niektore hrany su potencialne vzorove, ale oni hovoria o nejakom nekonzervativnom pristpe kde to splanarizuju a chcu tvrdit ze je to aj tak dost presne, resp. dokonca presnejsie, maju aj evaluaciu nakoniec
>>>
<<<
softwarePatternDetection
>>>
<<<
@INPROCEEDINGS{softwarePatternDetection, 
author={Pettersson, N. and Lowe, W.}, 
booktitle={Proceedings of the 2007 IEEE 15th International Conference on Program Comprehension}, 
title={{A Non-conservative Approach to Software Pattern Detection}}, 
year={2007}, 
month={June},
series={ICPC '07}, 
pages={189--198}, 
keywords={graph theory;object-oriented programming;software engineering;nonconservative approach;nonconservative filtering;planar graphs;program comprehension;reverse engineering;software pattern detection;software systems;structure graph;Bridges;Collaborative software;Filtering;Mathematics;Performance evaluation;Production facilities;Reverse engineering;Software systems;Systems engineering and theory;Visualization}, 
doi={10.1109/ICPC.2007.8}, 
ISSN={1092-8138},}
>>>
<<<
pattern detection;design pattern;program comprehension;
>>>

